<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Frappe Books</title>
  </head>
  <body></body>

  <script type="text/javascript">
    /*
    Copyright 2024 Open Foodservice System Consortium
    
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
    
        http://www.apache.org/licenses/LICENSE-2.0
    
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
    */
    
    // QR Code is a registered trademark of DENSO WAVE INCORPORATED.
    
    const Receipt = (() => {
        /**
         * Transform receipt markdown to printer commands or SVG images.
         * @param {string} markdown receipt markdown
         * @param {object} [printer] printer configuration
         * @returns {string} printer command or SVG image
         */
        const transform = async (markdown, printer) => {
            // initialize state variables
            const state = {
                wrap: true,
                border: 1,
                width: [],
                align: 1,
                option: { type: 'code128', width: 2, height: 72, hri: false, cell: 3, level: 'l' },
                line: 'waiting',
                rules: { left: 0, width: 0, right: 0, widths: [] }
            };
            // append commands to start printing
            let result = printer.command.open(printer);
            // strip bom
            if (markdown[0] === '\ufeff') {
                markdown = markdown.slice(1);
            }
            // parse each line and generate commands
            const res = [];
            for (let line of markdown.normalize().split(/\n|\r\n|\r/)) {
                res.push(await createLine(parseLine(line, state), printer, state));
            }
            // if rules is not finished
            switch (state.line) {
                case 'ready':
                    // set state to cancel rules
                    state.line = 'waiting';
                    break;
                case 'running':
                case 'horizontal':
                    // append commands to stop rules
                    res.push(printer.command.normal() +
                        printer.command.area(state.rules.left, state.rules.width, state.rules.right) +
                        printer.command.align(0) +
                        printer.command.vrstop(state.rules.widths) +
                        printer.command.vrlf(false));
                    state.line = 'waiting';
                    break;
                default:
                    break;
            }
            // flip upside down
            if (printer.upsideDown) {
                res.reverse();
            }
            // append commands
            result += res.join('');
            // append commands to end printing
            result += printer.command.close();
            return result;
        }
    
        /**
         * Parse lines.
         * @param {string} columns line text without line breaks
         * @param {object} state state variables
         * @returns {object} parsed line object
         */
        const parseLine = (columns, state) => {
            // extract columns
            const line = columns
                // trim whitespace
                .replace(/^[\t ]+|[\t ]+$/g, '')
                // convert escape characters ('\\', '\{', '\|', '\}') to hexadecimal escape characters
                .replace(/\\[\\{|}]/g, match => '\\x' + match.charCodeAt(1).toString(16))
                // append a space if the first column does not start with '|' and is right-aligned
                .replace(/^[^|]*[^\t |]\|/, ' $&')
                // append a space if the last column does not end with '|' and is left-aligned
                .replace(/\|[^\t |][^|]*$/, '$& ')
                // remove '|' at the beginning of the first column
                .replace(/^\|(.*)$/, '$1')
                // remove '|' at the end of the last column
                .replace(/^(.*)\|$/, '$1')
                // separate text with '|'
                .split('|')
                // parse columns
                .map((column, index, array) => {
                    // parsed column object
                    let result = {};
                    // trim whitespace
                    const element = column.replace(/^[\t ]+|[\t ]+$/g, '');
                    // determin alignment from whitespaces around column text
                    result.align = 1 + Number(/^[\t ]/.test(column)) - Number(/[\t ]$/.test(column));
                    // parse properties
                    if (/^\{[^{}]*\}$/.test(element)) {
                        // extract members
                        result.property = element
                            // trim property delimiters
                            .slice(1, -1)
                            // convert escape character ('\;') to hexadecimal escape characters
                            .replace(/\\;/g, '\\x3b')
                            // separate property with ';'
                            .split(';')
                            // parse members
                            .reduce((obj, member) => {
                                // abbreviations
                                const abbr = { a: 'align', b: 'border', c: 'code', i: 'image', o: 'option', t: 'text', w: 'width', x: 'command', _: 'comment' };
                                // parse key-value pair
                                if (!/^[\t ]*$/.test(member) &&
                                    member.replace(/^[\t ]*([A-Za-z_]\w*)[\t ]*:[\t ]*([^\t ].*?)[\t ]*$/,
                                        (match, key, value) => obj[key.replace(/^[abciotwx_]$/, m => abbr[m])] = parseEscape(value.replace(/\\n/g, '\n'))) === member) {
                                    // invalid members
                                    result.error = element;
                                }
                                return obj;
                            }, {});
                        // if the column is single
                        if (array.length === 1) {
                            // parse text property
                            if ('text' in result.property) {
                                const c = result.property.text.toLowerCase();
                                state.wrap = !/^nowrap$/.test(c);
                            }
                            // parse border property
                            if ('border' in result.property) {
                                const c = result.property.border.toLowerCase();
                                const border = { 'line': -1, 'space': 1, 'none': 0 };
                                const previous = state.border;
                                state.border = /^(line|space|none)$/.test(c) ? border[c.toLowerCase()] : /^\d+$/.test(c) && Number(c) <= 2 ? Number(c) : 1;
                                // start rules
                                if (previous >= 0 && state.border < 0) {
                                    result.vr = '+';
                                }
                                // stop rules
                                if (previous < 0 && state.border >= 0) {
                                    result.vr = '-';
                                }
                            }
                            // parse width property
                            if ('width' in result.property) {
                                const width = result.property.width.toLowerCase().split(/[\t ]+|,/);
                                state.width = width.find(c => /^auto$/.test(c)) ? [] : width.map(c => /^\*$/.test(c) ? -1 : /^\d+$/.test(c) ? Number(c) : 0);
                            }
                            // parse align property
                            if ('align' in result.property) {
                                const c = result.property.align.toLowerCase();
                                const align = { 'left': 0, 'center': 1, 'right': 2 };
                                state.align = /^(left|center|right)$/.test(c) ? align[c.toLowerCase()] : 1;
                            }
                            // parse option property
                            if ('option' in result.property) {
                                const option = result.property.option.toLowerCase().split(/[\t ]+|,/);
                                state.option = {
                                    type: (option.find(c => /^(upc|ean|jan|code39|itf|codabar|nw7|code93|code128|qrcode)$/.test(c)) || 'code128'),
                                    width: Number(option.find(c => /^\d+$/.test(c) && Number(c) >= 2 && Number(c) <= 4) || '2'),
                                    height: Number(option.find(c => /^\d+$/.test(c) && Number(c) >= 24 && Number(c) <= 240) || '72'),
                                    hri: !!option.find(c => /^hri$/.test(c)),
                                    cell: Number(option.find(c => /^\d+$/.test(c) && Number(c) >= 3 && Number(c) <= 8) || '3'),
                                    level: (option.find(c => /^[lmqh]$/.test(c)) || 'l')
                                };
                            }
                            // parse code property
                            if ('code' in result.property) {
                                result.code = Object.assign({ data: result.property.code }, state.option);
                            }
                            // parse image property
                            if ('image' in result.property) {
                                const c = result.property.image.replace(/=.*|[^A-Za-z0-9+/]/g, '');
                                switch (c.length % 4) {
                                    case 1:
                                        result.image = c.slice(0, -1);
                                        break;
                                    case 2:
                                        result.image = c + '==';
                                        break;
                                    case 3:
                                        result.image = c + '=';
                                        break;
                                    default:
                                        result.image = c;
                                        break;
                                }
                            }
                            // parse command property
                            if ('command' in result.property) {
                                result.command = result.property.command;
                            }
                            // parse comment property
                            if ('comment' in result.property) {
                                result.comment = result.property.comment;
                            }
                        }
                    }
                    // remove invalid property delimiter
                    else if (/[{}]/.test(element)) {
                        result.error = element;
                    }
                    // parse horizontal rule of special character in text
                    else if (array.length === 1 && /^-+$|^=+$/.test(element)) {
                        result.hr = element.slice(-1);
                    }
                    // parse text
                    else {
                        result.text = element
                            // remove control codes and hexadecimal control codes
                            .replace(/[\x00-\x1f\x7f]|\\x[01][\dA-Fa-f]|\\x7[Ff]/g, '')
                            // convert escape characters ('\-', '\=', '\_', '\"', \`', '\^', '\~') to hexadecimal escape characters
                            .replace(/\\[-=_"`^~]/g, match => '\\x' + match.charCodeAt(1).toString(16))
                            // convert escape character ('\n') to LF
                            .replace(/\\n/g, '\n')
                            // convert escape character ('~') to space
                            .replace(/~/g, ' ')
                            // separate text with '_', '"', '`', '^'(1 or more), '\n'
                            .split(/([_"`\n]|\^+)/)
                            // convert escape characters to normal characters
                            .map(text => parseEscape(text));
                    }
                    // set current text wrapping
                    result.wrap = state.wrap;
                    // set current column border
                    result.border = state.border;
                    // set current column width
                    if (state.width.length === 0) {
                        // set '*' for all columns when the width property is 'auto'
                        result.width = -1;
                    }
                    else if ('text' in result) {
                        // text: set column width
                        result.width = index < state.width.length ? state.width[index] : 0;
                    }
                    else if (state.width.find(c => c < 0)) {
                        // image, code, command: when the width property includes '*', set '*'
                        result.width = -1;
                    }
                    else {
                        // image, code, command: when the width property does not include '*', set the sum of column width and border width
                        const w = state.width.filter(c => c > 0);
                        result.width = w.length > 0 ? w.reduce((a, c) => a + c, result.border < 0 ? w.length + 1 : (w.length - 1) * result.border) : 0;
                    }
                    // set line alignment
                    result.alignment = state.align;
                    return result;
                });
            // if the line is text and the width property is not 'auto'
            if (line.every(el => 'text' in el) && state.width.length > 0) {
                // if the line has fewer columns
                while (line.length < state.width.length) {
                    // fill empty columns
                    line.push({ align: 1, text: [''], wrap: state.wrap, border: state.border, width: state.width[line.length] });
                }
            }
            return line;
        }
    
        /**
         * Parse escape characters.
         * @param {string} chars string containing escape characters
         * @returns {string} unescaped string
         */
        const parseEscape = chars => {
            return chars
                // remove invalid escape sequences
                .replace(/\\$|\\x(.?$|[^\dA-Fa-f].|.[^\dA-Fa-f])/g, '')
                // ignore invalid escape characters
                .replace(/\\[^x]/g, '')
                // convert hexadecimal escape characters to normal characters
                .replace(/\\x([\dA-Fa-f]{2})/g, (match, hex) => String.fromCharCode(parseInt(hex, 16)));
        }
    
        /**
         * Generate commands from line objects.
         * @param {object} line parsed line object
         * @param {object} printer printer configuration
         * @param {object} state state variables
         * @returns {string} printer command fragment or SVG image fragment
         */
        const createLine = async (line, printer, state) => {
            const result = [];
            // text or property
            const text = line.every(el => 'text' in el);
            // the first column
            const column = line[0];
            // remove zero width columns
            let columns = line.filter(el => el.width !== 0);
            // remove overflowing columns
            if (text) {
                columns = columns.slice(0, Math.floor(column.border < 0 ? (printer.cpl - 1) / 2 : (printer.cpl + column.border) / (column.border + 1)));
            }
            // fixed columns
            const f = columns.filter(el => el.width > 0);
            // variable columns
            const g = columns.filter(el => el.width < 0);
            // reserved width
            let u = f.reduce((a, el) => a + el.width, 0);
            // free width
            let v = printer.cpl - u;
            // subtract border width from free width
            if (text && columns.length > 0) {
                v -= column.border < 0 ? columns.length + 1 : (columns.length - 1) * column.border;
            }
            // number of variable columns
            const n = g.length;
            // reduce the width of fixed columns when reserved width is too many
            while (n > v) {
                f.reduce((a, el) => a.width > el.width ? a : el).width--;
                v++;
            }
            // allocate free width among variable columns
            if (n > 0) {
                g.forEach((el, i) => el.width = Math.floor((v + i) / n));
                v = 0;
            }
            // print area
            const left = Math.floor(v * column.alignment / 2);
            const width = printer.cpl - v;
            const right = v - left;
            // process text
            if (text) {
                // wrap text
                const cols = columns.map(column => wrapText(column, printer));
                // vertical line spacing
                const widths = columns.map(column => column.width);
                // rules
                switch (state.line) {
                    case 'ready':
                        // append commands to start rules
                        result.push(printer.command.normal() +
                            printer.command.area(left, width, right) +
                            printer.command.align(0) +
                            printer.command.vrstart(widths) +
                            printer.command.vrlf(true));
                        state.line = 'running';
                        break;
                    case 'horizontal':
                        // append commands to print horizontal rule
                        const m = left - state.rules.left;
                        const w = width - state.rules.width;
                        const l = Math.min(left, state.rules.left);
                        const r = Math.min(right, state.rules.right);
                        result.push(printer.command.normal() +
                            printer.command.area(l, printer.cpl - l - r, r) +
                            printer.command.align(0) +
                            printer.command.vrhr(state.rules.widths, widths, m, m + w) +
                            printer.command.lf());
                        state.line = 'running';
                        break;
                    default:
                        break;
                }
                // save parameters to stop rules
                state.rules = { left: left, width: width, right: right, widths: widths };
                // maximum number of wraps
                const row = column.wrap ? cols.reduce((a, col) => Math.max(a, col.length), 1) : 1;
                // sort text
                for (let j = 0; j < row; j++) {
                    // append commands to set print area and line alignment
                    let res = printer.command.normal() +
                        printer.command.area(left, width, right) +
                        printer.command.align(0);
                    // print position
                    let p = 0;
                    // process vertical rules
                    if (state.line === 'running') {
                        // maximum height
                        const height = cols.reduce((a, col) => j < col.length ? Math.max(a, col[j].height) : a, 1);
                        // append commands to print vertical rules
                        res += printer.command.normal() +
                            printer.command.absolute(p++) +
                            printer.command.vr(widths, height);
                    }
                    // process each column
                    cols.forEach((col, i) => {
                        // append commands to set print position of first column
                        res += printer.command.absolute(p);
                        // if wrapped text is not empty
                        if (j < col.length) {
                            // append commands to align text
                            res += printer.command.relative(col[j].margin);
                            // process text
                            const data = col[j].data;
                            for (let k = 0; k < data.length; k += 2) {
                                // append commands to decorate text
                                const ul = Number(data[k][0]);
                                const em = Number(data[k][1]);
                                const iv = Number(data[k][2]);
                                const wh = Number(data[k][3]);
                                res += printer.command.normal();
                                if (ul) {
                                    res += printer.command.ul();
                                }
                                if (em) {
                                    res += printer.command.em();
                                }
                                if (iv) {
                                    res += printer.command.iv();
                                }
                                if (wh) {
                                    res += printer.command.wh(wh);
                                }
                                // append commands to print text
                                res += printer.command.text(data[k + 1], printer.encoding);
                            }
                        }
                        // if wrapped text is empty
                        else {
                            res += printer.command.normal() + printer.command.text(' ', printer.encoding);
                        }
                        // append commands to set print position of next column
                        p += columns[i].width + Math.abs(column.border);
                    });
                    // append commands to feed new line
                    res += printer.command.lf();
                    result.push(res);
                }
            }
            // process horizontal rule or paper cut
            if ('hr' in column) {
                // process paper cut
                if (column.hr === '=') {
                    switch (state.line) {
                        case 'running':
                        case 'horizontal':
                            // append commands to stop rules
                            result.push(printer.command.normal() +
                                printer.command.area(state.rules.left, state.rules.width, state.rules.right) +
                                printer.command.align(0) +
                                printer.command.vrstop(state.rules.widths) +
                                printer.command.vrlf(false));
                            // append commands to cut paper
                            result.push(printer.command.cut());
                            // set state to start rules
                            state.line = 'ready';
                            break;
                        default:
                            // append commands to cut paper
                            result.push(printer.command.cut());
                            break;
                    }
                }
                // process horizontal rule
                else {
                    switch (state.line) {
                        case 'waiting':
                            // append commands to print horizontal rule
                            result.push(printer.command.normal() +
                                printer.command.area(left, width, right) +
                                printer.command.align(0) +
                                printer.command.hr(width) +
                                printer.command.lf());
                            break;
                        case 'running':
                            // set state to print horizontal rule
                            state.line = 'horizontal';
                            break;
                        default:
                            break;
                    }
                }
            }
            // process rules
            if ('vr' in column) {
                // start rules
                if (column.vr === '+') {
                    state.line = 'ready';
                }
                // stop rules
                else {
                    switch (state.line) {
                        case 'ready':
                            // set state to cancel rules
                            state.line = 'waiting';
                            break;
                        case 'running':
                        case 'horizontal':
                            // append commands to stop rules
                            result.push(printer.command.normal() +
                                printer.command.area(state.rules.left, state.rules.width, state.rules.right) +
                                printer.command.align(0) +
                                printer.command.vrstop(state.rules.widths) +
                                printer.command.vrlf(false));
                            state.line = 'waiting';
                            break;
                        default:
                            break;
                    }
                }
            }
            // process image
            if ('image' in column) {
                // append commands to print image
                result.push(printer.command.normal() +
                    printer.command.area(left, width, right) +
                    printer.command.align(column.align) +
                    await printer.command.image(column.image));
            }
            // process barcode or 2D code
            if ('code' in column) {
                // process 2D code
                if (column.code.type === 'qrcode') {
                    // append commands to print 2D code
                    result.push(printer.command.normal() +
                        printer.command.area(left, width, right) +
                        printer.command.align(column.align) +
                        printer.command.qrcode(column.code, printer.encoding));
                }
                // process barcode
                else {
                    // append commands to print barcode
                    result.push(printer.command.normal() +
                        printer.command.area(left, width, right) +
                        printer.command.align(column.align) +
                        printer.command.barcode(column.code, printer.encoding));
                }
            }
            // process command
            if ('command' in column) {
                // append commands to insert commands
                result.push(printer.command.normal() +
                    printer.command.area(left, width, right) +
                    printer.command.align(column.align) +
                    printer.command.command(column.command));
            }
            // flip upside down
            if (printer.upsideDown) {
                result.reverse();
            }
            return result.join('');
        }
    
        /**
         * Wrap text.
         * @param {object} column parsed column object
         * @param {object} printer printer configuration
         * @returns {object[]} wrapped text, text position, and text height
         */
        const wrapText = (column, printer) => {
            const result = [];
            // remaining spaces
            let space = column.width;
            // text height
            let height = 1;
            // text data
            let res = [];
            // text decoration flags
            let ul = false;
            let em = false;
            let iv = false;
            let wh = 0;
            // process text and text decoration
            column.text.forEach((text, i) => {
                // process text
                if (i % 2 === 0) {
                    // if text is not empty
                    let t = printer.command.arrayFrom(text, printer.encoding);
                    while (t.length > 0) {
                        // measure character width
                        let w = 0;
                        let j = 0;
                        while (j < t.length) {
                            w = printer.command.measureText(t[j], printer.encoding) * (wh < 2 ? wh + 1 : wh - 1);
                            // output before protruding
                            if (w > space) {
                                break;
                            }
                            space -= w;
                            w = 0;
                            j++;
                        }
                        // if characters fit
                        if (j > 0) {
                            // append text decoration information
                            res.push((ul ? '1' : '0') + (em ? '1' : '0') + (iv ? '1' : '0') + wh);
                            // append text
                            res.push(t.slice(0, j).join(''));
                            // update text height
                            height = Math.max(height, wh < 3 ? wh : wh - 1);
                            // remaining text
                            t = t.slice(j);
                        }
                        // if character is too big
                        if (w > column.width) {
                            // do not output
                            t = t.slice(1);
                            continue;
                        }
                        // if there is no spece left
                        if (w > space || space === 0) {
                            // wrap text automatically
                            result.push({ data: res, margin: space * column.align / 2, height: height });
                            space = column.width;
                            res = [];
                            height = 1;
                        }
                    }
                }
                // process text decoration
                else {
                    // update text decoration flags
                    switch (text) {
                        case '\n':
                            // wrap text manually
                            result.push({ data: res, margin: space * column.align / 2, height: height });
                            space = column.width;
                            res = [];
                            height = 1;
                            break;
                        case '_':
                            ul = !ul;
                            break;
                        case '"':
                            em = !em;
                            break;
                        case '`':
                            iv = !iv;
                            break;
                        default:
                            const d = Math.min(text.length, 7);
                            wh = wh === d ? 0 : d;
                            break;
                    }
                }
            });
            // output last text
            if (res.length > 0) {
                result.push({ data: res, margin: space * column.align / 2, height: height });
            }
            return result;
        }
    
        //
        // Barcode generator
        //
        const barcode = (() => {
            // CODE128 patterns:
            const c128 = {
                element: '212222,222122,222221,121223,121322,131222,122213,122312,132212,221213,221312,231212,112232,122132,122231,113222,123122,123221,223211,221132,221231,213212,223112,312131,311222,321122,321221,312212,322112,322211,212123,212321,232121,111323,131123,131321,112313,132113,132311,211313,231113,231311,112133,112331,132131,113123,113321,133121,313121,211331,231131,213113,213311,213131,311123,311321,331121,312113,312311,332111,314111,221411,431111,111224,111422,121124,121421,141122,141221,112214,112412,122114,122411,142112,142211,241211,221114,413111,241112,134111,111242,121142,121241,114212,124112,124211,411212,421112,421211,212141,214121,412121,111143,111341,131141,114113,114311,411113,411311,113141,114131,311141,411131,211412,211214,211232,2331112'.split(','),
                starta: 103, startb: 104, startc: 105, atob: 100, atoc: 99, btoa: 101, btoc: 99, ctoa: 101, ctob: 100, shift: 98, stop: 106
            };
            // generate CODE128 data (minimize symbol width):
            const code128 = symbol => {
                const r = {};
                let s = symbol.data.replace(/((?!^[\x00-\x7f]+$).)*/, '');
                if (s.length > 0) {
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = s.replace(/[\x00- \x7f]/g, ' ');
                    // minimize symbol width
                    const d = [];
                    const p = s.search(/[^ -_]/);
                    if (/^\d{2}$/.test(s)) {
                        d.push(c128.startc, Number(s));
                    }
                    else if (/^\d{4,}/.test(s)) {
                        code128c(c128.startc, s, d);
                    }
                    else if (p >= 0 && s.charCodeAt(p) < 32) {
                        code128a(c128.starta, s, d);
                    }
                    else if (s.length > 0) {
                        code128b(c128.startb, s, d);
                    }
                    else {
                        // end
                    }
                    // calculate check digit and append stop character
                    d.push(d.reduce((a, c, i) => a + c * i) % 103, c128.stop);
                    // generate bars and spaces
                    const q = symbol.quietZone ? 'a' : '0';
                    const m = d.reduce((a, c) => a + c128.element[c], q) + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width);
                    r.length = symbol.width * (d.length * 11 + (symbol.quietZone ? 22 : 2));
                    r.height = symbol.height;
                }
                return r;
            };
            // process CODE128 code set A:
            const code128a = (x, s, d) => {
                if (x !== c128.shift) {
                    d.push(x);
                }
                s = s.replace(/^((?!\d{4,})[\x00-_])+/, m => (m.split('').forEach(c => d.push((c.charCodeAt(0) + 64) % 96)), ''));
                s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push((m.charCodeAt(0) + 64) % 96), ''));
                const t = s.slice(1);
                const p = t.search(/[^ -_]/);
                if (/^\d{4,}/.test(s)) {
                    code128c(c128.atoc, s, d);
                }
                else if (p >= 0 && t.charCodeAt(p) < 32) {
                    d.push(c128.shift, s.charCodeAt(0) - 32);
                    code128a(c128.shift, t, d);
                }
                else if (s.length > 0) {
                    code128b(c128.atob, s, d);
                }
                else {
                    // end
                }
            };
            // process CODE128 code set B:
            const code128b = (x, s, d) => {
                if (x !== c128.shift) {
                    d.push(x);
                }
                s = s.replace(/^((?!\d{4,})[ -\x7f])+/, m => (m.split('').forEach(c => d.push(c.charCodeAt(0) - 32)), ''));
                s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push(m.charCodeAt(0) - 32), ''));
                const t = s.slice(1);
                const p = t.search(/[^ -_]/);
                if (/^\d{4,}/.test(s)) {
                    code128c(c128.btoc, s, d);
                }
                else if (p >= 0 && t.charCodeAt(p) > 95) {
                    d.push(c128.shift, s.charCodeAt(0) + 64);
                    code128b(c128.shift, t, d);
                }
                else if (s.length > 0) {
                    code128a(c128.btoa, s, d);
                }
                else {
                    // end
                }
            };
            // process CODE128 code set C:
            const code128c = (x, s, d) => {
                if (x !== c128.shift) {
                    d.push(x);
                }
                s = s.replace(/^\d{4,}/g, m => m.replace(/\d{2}/g, c => (d.push(Number(c)), '')));
                const p = s.search(/[^ -_]/);
                if (p >= 0 && s.charCodeAt(p) < 32) {
                    code128a(c128.ctoa, s, d);
                }
                else if (s.length > 0) {
                    code128b(c128.ctob, s, d);
                }
                else {
                    // end
                }
            };
            // CODE93 patterns:
            const c93 = {
                escape: 'cU,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,cA,cB,cC,cD,cE, ,sA,sB,sC,$,%,sF,sG,sH,sI,sJ,+,sL,-,.,/,0,1,2,3,4,5,6,7,8,9,sZ,cF,cG,cH,cI,cJ,cV,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,cK,cL,cM,cN,cO,cW,pA,pB,pC,pD,pE,pF,pG,pH,pI,pJ,pK,pL,pM,pN,pO,pP,pQ,pR,pS,pT,pU,pV,pW,pX,pY,pZ,cP,cQ,cR,cS,cT'.split(','),
                code: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%dcsp'.split('').reduce((a, c, i) => (a[c] = i, a), {}),
                element: '131112,111213,111312,111411,121113,121212,121311,111114,131211,141111,211113,211212,211311,221112,221211,231111,112113,112212,112311,122112,132111,111123,111222,111321,121122,131121,212112,212211,211122,211221,221121,222111,112122,112221,122121,123111,121131,311112,311211,321111,112131,113121,211131,121221,312111,311121,122211,111141,1111411'.split(','),
                start: 47, stop: 48
            };
            // generate CODE93 data:
            const code93 = symbol => {
                const r = {};
                let s = symbol.data.replace(/((?!^[\x00-\x7f]+$).)*/, '');
                if (s.length > 0) {
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = s.replace(/[\x00- \x7f]/g, ' ');
                    // calculate check digit
                    const d = s.split('').reduce((a, c) => a + c93.escape[c.charCodeAt(0)], '').split('').map(c => c93.code[c]);
                    d.push(d.reduceRight((a, c, i) => a + c * ((d.length - 1 - i) % 20 + 1)) % 47);
                    d.push(d.reduceRight((a, c, i) => a + c * ((d.length - 1 - i) % 15 + 1)) % 47);
                    // append start character and stop character
                    d.unshift(c93.start);
                    d.push(c93.stop);
                    // generate bars and spaces
                    const q = symbol.quietZone ? 'a' : '0';
                    const m = d.reduce((a, c) => a + c93.element[c], q) + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width);
                    r.length = symbol.width * (d.length * 9 + (symbol.quietZone ? 21 : 1));
                    r.height = symbol.height;
                }
                return r;
            };
            // Codabar(NW-7) patterns:
            const nw7 = {
                '0': '2222255', '1': '2222552', '2': '2225225', '3': '5522222', '4': '2252252',
                '5': '5222252', '6': '2522225', '7': '2522522', '8': '2552222', '9': '5225222',
                '-': '2225522', '$': '2255222', ':': '5222525', '/': '5252225', '.': '5252522',
                '+': '2252525', 'A': '2255252', 'B': '2525225', 'C': '2225255', 'D': '2225552'
            };
            // generate Codabar(NW-7) data:
            const codabar = symbol => {
                const r = {};
                let s = symbol.data.replace(/((?!^[A-D][0-9\-$:/.+]+[A-D]$).)*/i, '');
                if (s.length > 0) {
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = s;
                    // generate bars and spaces
                    const q = symbol.quietZone ? 'a' : '0';
                    const m = s.toUpperCase().split('').reduce((a, c) => a + nw7[c] + '2', q).slice(0, -1) + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width + 1 >> 1);
                    const w = [ 25, 39, 50, 3, 5, 6 ];
                    r.length = s.length * w[symbol.width - 2] - (s.match(/[\d\-$]/g) || []).length * w[symbol.width + 1] + symbol.width * (symbol.quietZone ? 19 : -1);
                    r.height = symbol.height;
                }
                return r;
            };
            // Interleaved 2 of 5 patterns:
            const i25 = {
                element: '22552,52225,25225,55222,22525,52522,25522,22255,52252,25252'.split(','),
                start: '2222', stop: '522'
            };
            // generate Interleaved 2 of 5 data:
            const itf = symbol => {
                const r = {};
                let s = symbol.data.replace(/((?!^(\d{2})+$).)*/, '');
                if (s.length > 0) {
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = s;
                    // generate bars and spaces
                    const d = symbol.data.replace(/((?!^(\d{2})+$).)*/, '', '').split('').map(c => Number(c));
                    const q = symbol.quietZone ? 'a' : '0';
                    let m = q + i25.start;
                    let i = 0;
                    while (i < d.length) {
                        const b = i25.element[d[i++]];
                        const s = i25.element[d[i++]];
                        m += b.split('').reduce((a, c, j) => a + c + s[j], '');
                    }
                    m += i25.stop + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width + 1 >> 1);
                    const w = [ 16, 25, 32, 17, 26, 34 ];
                    r.length = s.length * w[symbol.width - 2] + w[symbol.width + 1] + symbol.width * (symbol.quietZone ? 20 : 0);
                    r.height = symbol.height;
                }
                return r;
            };
            // CODE39 patterns:
            const c39 = {
                '0': '222552522', '1': '522522225', '2': '225522225', '3': '525522222', '4': '222552225',
                '5': '522552222', '6': '225552222', '7': '222522525', '8': '522522522', '9': '225522522',
                'A': '522225225', 'B': '225225225', 'C': '525225222', 'D': '222255225', 'E': '522255222',
                'F': '225255222', 'G': '222225525', 'H': '522225522', 'I': '225225522', 'J': '222255522',
                'K': '522222255', 'L': '225222255', 'M': '525222252', 'N': '222252255', 'O': '522252252',
                'P': '225252252', 'Q': '222222555', 'R': '522222552', 'S': '225222552', 'T': '222252552',
                'U': '552222225', 'V': '255222225', 'W': '555222222', 'X': '252252225', 'Y': '552252222',
                'Z': '255252222', '-': '252222525', '.': '552222522', ' ': '255222522', '$': '252525222',
                '/': '252522252', '+': '252225252', '%': '222525252', '*': '252252522'
            };
            // generate CODE39 data:
            const code39 = symbol => {
                const r = {};
                let s = symbol.data.replace(/((?!^\*?[0-9A-Z\-. $/+%]+\*?$).)*/, '');
                if (s.length > 0) {
                    // append start character and stop character
                    s = s.replace(/^\*?([^*]+)\*?$/, '*$1*');
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = s;
                    // generate bars and spaces
                    const q = symbol.quietZone ? 'a' : '0';
                    const m = s.split('').reduce((a, c) => a + c39[c] + '2', q).slice(0, -1) + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width + 1 >> 1);
                    const w = [ 29, 45, 58 ];
                    r.length = s.length * w[symbol.width - 2] + symbol.width * (symbol.quietZone ? 19 : -1);
                    r.height = symbol.height;
                }
                return r;
            };
            // UPC/EAN/JAN patterns:
            const ean = {
                a: '3211,2221,2122,1411,1132,1231,1114,1312,1213,3112'.split(','),
                b: '1123,1222,2212,1141,2311,1321,4111,2131,3121,2113'.split(','),
                c: '3211,2221,2122,1411,1132,1231,1114,1312,1213,3112'.split(','),
                g: '111,11111,111111,11,112'.split(','),
                p: 'aaaaaa,aababb,aabbab,aabbba,abaabb,abbaab,abbbaa,ababab,ababba,abbaba'.split(','),
                e: 'bbbaaa,bbabaa,bbaaba,bbaaab,babbaa,baabba,baaabb,bababa,babaab,baabab'.split(',')
            };
            // generate UPC-A data:
            const upca = symbol => {
                const s = Object.assign({}, symbol);
                s.data = '0' + symbol.data;
                const r = ean13(s);
                if ('text' in r) {
                    r.text = r.text.slice(1);
                }
                return r;
            };
            // generate UPC-E data:
            const upce = symbol => {
                const r = {};
                const d = symbol.data.replace(/((?!^0\d{6,7}$).)*/, '').split('').map(c => Number(c));
                if (d.length > 0) {
                    // calculate check digit
                    d[7] = 0;
                    d[7] = (10 - upcetoa(d).reduce((a, c, i) => a + c * (3 - (i % 2) * 2), 0) % 10) % 10;
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = d.join('');
                    // generate bars and spaces
                    const q = symbol.quietZone ? '7' : '0';
                    let m = q + ean.g[0];
                    for (let i = 1; i < 7; i++) m += ean[ean.e[d[7]][i - 1]][d[i]];
                    m += ean.g[2] + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width);
                    r.length = symbol.width * (symbol.quietZone ? 65 : 51);
                    r.height = symbol.height;
                }
                return r;
            };
            // convert UPC-E to UPC-A:
            const upcetoa = e => {
                const a = e.slice(0, 3);
                switch (e[6]) {
                    case 0: case 1: case 2:
                        a.push(e[6], 0, 0, 0, 0, e[3], e[4], e[5]);
                        break;
                    case 3:
                        a.push(e[3], 0, 0, 0, 0, 0, e[4], e[5]);
                        break;
                    case 4:
                        a.push(e[3], e[4], 0, 0, 0, 0, 0, e[5]);
                        break;
                    default:
                        a.push(e[3], e[4], e[5], 0, 0, 0, 0, e[6]);
                        break;
                }
                a.push(e[7]);
                return a;
            };
            // generate EAN-13(JAN-13) data:
            const ean13 = symbol => {
                const r = {};
                const d = symbol.data.replace(/((?!^\d{12,13}$).)*/, '').split('').map(c => Number(c));
                if (d.length > 0) {
                    // calculate check digit
                    d[12] = 0;
                    d[12] = (10 - d.reduce((a, c, i) => a + c * ((i % 2) * 2 + 1)) % 10) % 10;
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = d.join('');
                    // generate bars and spaces
                    let m = (symbol.quietZone ? 'b' : '0') + ean.g[0];
                    for (let i = 1; i < 7; i++) m += ean[ean.p[d[0]][i - 1]][d[i]];
                    m += ean.g[1];
                    for (let i = 7; i < 13; i++) m += ean.c[d[i]];
                    m += ean.g[0] + (symbol.quietZone ? '7' : '0');
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width);
                    r.length = symbol.width * (symbol.quietZone ? 113 : 95);
                    r.height = symbol.height;
                }
                return r;
            };
            // generate EAN-8(JAN-8) data:
            const ean8 = symbol => {
                const r = {};
                const d = symbol.data.replace(/((?!^\d{7,8}$).)*/, '').split('').map(c => Number(c));
                if (d.length > 0) {
                    // calculate check digit
                    d[7] = 0;
                    d[7] = (10 - d.reduce((a, c, i) => a + c * (3 - (i % 2) * 2), 0) % 10) % 10;
                    // generate HRI
                    r.hri = symbol.hri;
                    r.text = d.join('');
                    // generate bars and spaces
                    const q = symbol.quietZone ? '7' : '0';
                    let m = q + ean.g[0];
                    for (let i = 0; i < 4; i++) m += ean.a[d[i]];
                    m += ean.g[1];
                    for (let i = 4; i < 8; i++) m += ean.c[d[i]];
                    m += ean.g[0] + q;
                    r.widths = m.split('').map(c => parseInt(c, 16) * symbol.width);
                    r.length = symbol.width * (symbol.quietZone ? 81 : 67);
                    r.height = symbol.height;
                }
                return r;
            };
            return {
                /**
                 * Generate barcode.
                 * @param {object} symbol barcode information (data, type, width, height, hri, quietZone)
                 * @returns {object} barcode form
                 */
                generate(symbol) {
                    let r = {};
                    switch (symbol.type) {
                        case 'upc':
                            r = symbol.data.length < 9 ? upce(symbol) : upca(symbol);
                            break;
                        case 'ean':
                        case 'jan':
                            r = symbol.data.length < 9 ? ean8(symbol) : ean13(symbol);
                            break;
                        case 'code39':
                            r = code39(symbol);
                            break;
                        case 'itf':
                            r = itf(symbol);
                            break;
                        case 'codabar':
                        case 'nw7':
                            r = codabar(symbol);
                            break;
                        case 'code93':
                            r = code93(symbol);
                            break;
                        case 'code128':
                            r = code128(symbol);
                            break;
                        default:
                            break;
                    }
                    return r;
                }
            };
        })();
    
        //
        // Command base object
        //
        const _base = {
            /**
             * Character width.
             * @type {number} character width (dots per character)
             */
            charWidth: 12,
            /**
             * Measure text width.
             * @param {string} text string to measure
             * @param {string} encoding codepage
             * @returns {number} string width
             */
            measureText(text, encoding) {
                let r = 0;
                const t = Array.from(text);
                switch (encoding) {
                    case 'cp932':
                    case 'shiftjis':
                        r = t.reduce((a, c) => {
                            const d = c.codePointAt(0);
                            return a + (d < 0x80 || d === 0xa5 || d === 0x203e || (d > 0xff60 && d < 0xffa0) ? 1 : 2);
                        }, 0);
                        break;
                    case 'cp936':
                    case 'gb18030':
                    case 'cp949':
                    case 'ksc5601':
                    case 'cp950':
                    case 'big5':
                        r = t.reduce((a, c) => a + (c.codePointAt(0) < 0x80 ? 1 : 2), 0);
                        break;
                    case 'tis620':
                        const a = t.reduce((a, c) => {
                            const d = c.codePointAt(0);
                            if (a.consonant) {
                                if (d === 0xe31 || d >= 0xe34 && d <= 0xe3a || d === 0xe47) {
                                    if (a.vowel) {
                                        a.length += 2;
                                        a.consonant = a.vowel = a.tone = false;
                                    }
                                    else {
                                        a.vowel = true;
                                    }
                                }
                                else if (d >= 0xe48 && d <= 0xe4b) {
                                    if (a.tone) {
                                        a.length += 2;
                                        a.consonant = a.vowel = a.tone = false;
                                    }
                                    else {
                                        a.tone = true;
                                    }
                                }
                                else if (d === 0xe33 || d >= 0xe4c && d <= 0xe4e) {
                                    if (a.vowel || a.tone) {
                                        a.length += 2;
                                        a.consonant = a.vowel = a.tone = false;
                                    }
                                    else {
                                        a.length += d === 0xe33 ? 2 : 1;
                                        a.consonant = false;
                                    }
                                }
                                else if (d >= 0xe01 && d <= 0xe2e) {
                                    a.length++;
                                    a.vowel = a.tone = false;
                                }
                                else {
                                    a.length += 2;
                                    a.consonant = a.vowel = a.tone = false;
                                }
                            }
                            else if (d >= 0xe01 && d <= 0xe2e) {
                                a.consonant = true;
                            }
                            else {
                                a.length++;
                            }
                            return a;
                        }, { length: 0, consonant: false, vowel: false, tone: false });
                        if (a.consonant) {
                            a.length++;
                            a.consonant = a.vowel = a.tone = false;
                        }
                        r = a.length;
                        break;
                    default:
                        r = t.length;
                        break;
                }
                return r;
            },
            /**
             * Create character array from string (supporting Thai combining characters).
             * @param {string} text string
             * @param {string} encoding codepage
             * @returns {string[]} array instance
             */
            arrayFrom(text, encoding) {
                const t = Array.from(text);
                if (encoding === 'tis620') {
                    const a = t.reduce((a, c) => {
                        const d = c.codePointAt(0);
                        if (a.consonant) {
                            if (d === 0xe31 || d >= 0xe34 && d <= 0xe3a || d === 0xe47) {
                                if (a.vowel) {
                                    a.result.push(a.consonant + a.vowel + a.tone, c);
                                    a.consonant = a.vowel = a.tone = '';
                                }
                                else {
                                    a.vowel = c;
                                }
                            }
                            else if (d >= 0xe48 && d <= 0xe4b) {
                                if (a.tone) {
                                    a.result.push(a.consonant + a.vowel + a.tone, c);
                                    a.consonant = a.vowel = a.tone = '';
                                }
                                else {
                                    a.tone = c;
                                }
                            }
                            else if (d === 0xe33 || d >= 0xe4c && d <= 0xe4e) {
                                if (a.vowel || a.tone) {
                                    a.result.push(a.consonant + a.vowel + a.tone, c);
                                    a.consonant = a.vowel = a.tone = '';
                                }
                                else {
                                    a.result.push(a.consonant + c);
                                    a.consonant = '';
                                }
                            }
                            else if (d >= 0xe01 && d <= 0xe2e) {
                                a.result.push(a.consonant + a.vowel + a.tone);
                                a.consonant = c;
                                a.vowel = a.tone = '';
                            }
                            else {
                                a.result.push(a.consonant + a.vowel + a.tone, c);
                                a.consonant = a.vowel = a.tone = '';
                            }
                        }
                        else if (d >= 0xe01 && d <= 0xe2e) {
                            a.consonant = c;
                        }
                        else {
                            a.result.push(c);
                        }
                        return a;
                    }, { result: [], consonant: '', vowel: '', tone: '' });
                    if (a.consonant) {
                        a.result.push(a.consonant + a.vowel + a.tone);
                        a.consonant = a.vowel = a.tone = '';
                    }
                    return a.result;
                }
                else {
                    return t;
                }
            },
            /**
             * Start printing.
             * @param {object} printer printer configuration
             * @returns {string} commands
             */
            open(printer) {
                return '';
            },
            /**
             * Finish printing.
             * @returns {string} commands
             */
            close() {
                return '';
            },
            /**
             * Set print area.
             * @param {number} left left margin (unit: characters)
             * @param {number} width print area (unit: characters)
             * @param {number} right right margin (unit: characters)
             * @returns {string} commands
             */
            area(left, width, right) {
                return '';
            },
            /**
             * Set line alignment.
             * @param {number} align line alignment (0: left, 1: center, 2: right)
             * @returns {string} commands
             */
            align(align) {
                return '';
            },
            /**
             * Set absolute print position.
             * @param {number} position absolute position (unit: characters)
             * @returns {string} commands
             */
            absolute(position) {
                return '';
            },
            /**
             * Set relative print position.
             * @param {number} position relative position (unit: characters)
             * @returns {string} commands
             */
            relative(position) {
                return '';
            },
            /**
             * Print horizontal rule.
             * @param {number} width line width (unit: characters)
             * @returns {string} commands
             */
            hr(width) {
                return '';
            },
            /**
             * Print vertical rules.
             * @param {number[]} widths vertical line spacing
             * @param {number} height text height (1-6)
             * @returns {string} commands
             */
            vr(widths, height) {
                return '';
            },
            /**
             * Start rules.
             * @param {number[]} widths vertical line spacing
             * @returns {string} commands
             */
            vrstart(widths) {
                return '';
            },
            /**
             * Stop rules.
             * @param {number[]} widths vertical line spacing
             * @returns {string} commands
             */
            vrstop(widths) {
                return '';
            },
            /**
             * Print vertical and horizontal rules.
             * @param {number[]} widths1 vertical line spacing (stop)
             * @param {number[]} widths2 vertical line spacing (start)
             * @param {number} dl difference in left position
             * @param {number} dr difference in right position
             * @returns {string} commands
             */
            vrhr(widths1, widths2, dl, dr) {
                return '';
            },
            /**
             * Set line spacing and feed new line.
             * @param {boolean} vr whether vertical ruled lines are printed
             * @returns {string} commands
             */
            vrlf(vr) {
                return '';
            },
            /**
             * Cut paper.
             * @returns {string} commands
             */
            cut() {
                return '';
            },
            /**
             * Underline text.
             * @returns {string} commands
             */
            ul() {
                return '';
            },
            /**
             * Emphasize text.
             * @returns {string} commands
             */
            em() {
                return '';
            },
            /**
             * Invert text.
             * @returns {string} commands
             */
            iv() {
                return '';
            },
            /**
             * Scale up text.
             * @param {number} wh number of special character '^' (1-7)
             * @returns {string} commands
             */
            wh(wh) {
                return '';
            },
            /**
             * Cancel text decoration.
             * @returns {string} commands
             */
            normal() {
                return '';
            },
            /**
             * Print text.
             * @param {string} text string to print
             * @param {string} encoding codepage
             * @returns {string} commands
             */
            text(text, encoding) {
                return '';
            },
            /**
             * Feed new line.
             * @returns {string} commands
             */
            lf() {
                return '';
            },
            /**
             * Insert commands.
             * @param {string} command commands to insert
             * @returns {string} commands
             */
            command(command) {
                return '';
            },
            /**
             * Print image.
             * @param {string} image image data (base64 png format)
             * @returns {string} commands
             */
            async image(image) {
                return '';
            },
            /**
             * Print QR Code.
             * @param {object} symbol QR Code information (data, type, cell, level)
             * @param {string} encoding codepage
             * @returns {string} commands
             */
            qrcode(symbol, encoding) {
                return '';
            },
            /**
             * Print barcode.
             * @param {object} symbol barcode information (data, type, width, height, hri)
             * @param {string} encoding codepage
             * @returns {string} commands
             */
            barcode(symbol, encoding) {
                return '';
            }
        };
    
        //
        // SVG
        //
        const _svg = {
            svgWidth: 576,
            svgHeight: 0,
            svgContent: '',
            lineMargin: 0,
            lineAlign: 0,
            lineWidth: 48,
            lineHeight: 1,
            textElement: '',
            textAttributes: {},
            textPosition: 0,
            textScale: 1,
            textEncoding: '',
            feedMinimum: 24,
            // printer configuration
            spacing: false,
            // start printing:
            open(printer) {
                this.svgWidth = printer.cpl * this.charWidth;
                this.svgHeight = 0;
                this.svgContent = '';
                this.lineMargin = 0;
                this.lineAlign = 0;
                this.lineWidth = printer.cpl;
                this.lineHeight = 1;
                this.textElement = '';
                this.textAttributes = {};
                this.textPosition = 0;
                this.textScale = 1;
                this.textEncoding = printer.encoding;
                this.feedMinimum = Number(this.charWidth * (printer.spacing ? 2.5 : 2));
                this.spacing = printer.spacing;
                return '';
            },
            // finish printing:
            close() {
                const p = { font: 'monospace', size: this.charWidth * 2, weight: 'normal', lang: '' };
                switch (this.textEncoding) {
                    case 'cp932':
                    case 'shiftjis':
                        p.font = `'MS Gothic', 'San Francisco', 'Osaka-Mono', monospace`;
                        p.lang = 'ja';
                        break;
                    case 'cp936':
                    case 'gb18030':
                        p.size -= 2;
                        p.lang = 'zh-Hans';
                        break;
                    case 'cp949':
                    case 'ksc5601':
                        p.size -= 2;
                        p.lang = 'ko';
                        break;
                    case 'cp950':
                    case 'big5':
                        p.size -= 2;
                        p.lang = 'zh-Hant';
                        break;
                    case 'tis620':
                        p.font = `monospace`;
                        p.size -= 4;
                        p.lang = 'th';
                        break;
                    default:
                        p.font = `'Courier New', 'Courier', monospace`;
                        p.size -= 2;
                        p.weight = 'bold';
                        break;
                }
                if (p.lang.length > 0) {
                    p.lang = ` xml:lang="${p.lang}"`;
                }
                return `<svg width="${this.svgWidth}px" height="${this.svgHeight}px" viewBox="0 0 ${this.svgWidth} ${this.svgHeight}" preserveAspectRatio="xMinYMin meet" ` +
                    `xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1">` +
                    `<defs><filter id="receiptinvert" x="0" y="0" width="100%" height="100%"><feFlood flood-color="#000"/><feComposite in="SourceGraphic" operator="xor"/></filter></defs>` +
                    `<g font-family="${p.font}" fill="#000" font-size="${p.size}" font-weight="${p.weight}" dominant-baseline="text-after-edge" text-anchor="middle"${p.lang}>${this.svgContent}</g></svg>\n`;
            },
            // set print area:
            area(left, width, right) {
                this.lineMargin = left;
                this.lineWidth = width;
                return '';
            },
            // set line alignment:
            align(align) {
                this.lineAlign = align;
                return '';
            },
            // set absolute print position:
            absolute(position) {
                this.textPosition = position;
                return '';
            },
            // set relative print position:
            relative(position) {
                this.textPosition += position;
                return '';
            },
            // print horizontal rule:
            hr(width) {
                const w = this.charWidth;
                const path = `<path d="M0,${w}h${w * width}" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${this.lineMargin * w},${this.svgHeight})">${path}</g>`;
                return '';
            },
            // print vertical rules:
            vr(widths, height) {
                const w = this.charWidth, u = w / 2, v = (w + w) * height;
                const path = `<path d="` + widths.reduce((a, width) => a + `m${w * width + w},${-v}v${v}`, `M${u},0v${v}`) + `" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${this.lineMargin * w},${this.svgHeight})">${path}</g>`;
                return '';
            },
            // start rules:
            vrstart(widths) {
                const w = this.charWidth, u = w / 2;
                const path = `<path d="` + widths.reduce((a, width) => a + `h${w * width}h${u}v${w}m0,${-w}h${u}`, `M${u},${w + w}v${-u}q0,${-u},${u},${-u}`).replace(/h\d+v\d+m0,-\d+h\d+$/, `q${u},0,${u},${u}v${u}`) + `" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${this.lineMargin * w},${this.svgHeight})">${path}</g>`;
                return '';
            },
            // stop rules:
            vrstop(widths) {
                const w = this.charWidth, u = w / 2;
                const path = `<path d="` + widths.reduce((a, width) => a + `h${w * width}h${u}v${-w}m0,${w}h${u}`, `M${u},0v${u}q0,${u},${u},${u}`).replace(/h\d+v-\d+m0,\d+h\d+$/, `q${u},0,${u},${-u}v${-u}`) + `" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${this.lineMargin * w},${this.svgHeight})">${path}</g>`;
                return '';
            },
            // print vertical and horizontal rules:
            vrhr(widths1, widths2, dl, dr) {
                const w = this.charWidth, u = w / 2;
                const path1 = `<path d="` + widths1.reduce((a, width) => a + `h${w * width}h${u}v${-w}m0,${w}h${u}`, `M${u},0` + (dl > 0 ? `v${u}q0,${u},${u},${u}`: `v${w}h${u}`)).replace(/h\d+v-\d+m0,\d+h\d+$/, dr < 0 ? `q${u},0,${u},${-u}v${-u}` : `h${u}v${-w}`) + `" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${(this.lineMargin + Math.max(-dl, 0)) * w},${this.svgHeight})">${path1}</g>`;
                const path2 = `<path d="` + widths2.reduce((a, width) => a + `h${w * width}h${u}v${w}m0,${-w}h${u}`, `M${u},${w + w}` + (dl < 0 ? `v${-u}q0,${-u},${u},${-u}`: `v${-w}h${u}`)).replace(/h\d+v\d+m0,-\d+h\d+$/, dr > 0 ? `q${u},0,${u},${u}v${u}` : `h${u}v${w}`) + `" fill="none" stroke="#000" stroke-width="2"/>`;
                this.svgContent += `<g transform="translate(${(this.lineMargin + Math.max(dl, 0)) * w},${this.svgHeight})">${path2}</g>`;
                return '';
            },
            // set line spacing and feed new line:
            vrlf(vr) {
                this.feedMinimum = Number(this.charWidth * (!vr && this.spacing ? 2.5 : 2));
                return this.lf();
            },
            // cut paper:
            cut() {
                const path = `<path d="M12,12.5l-7.5,-3a2,2,0,1,1,.5,0M12,11.5l-7.5,3a2,2,0,1,0,.5,0" fill="none" stroke="#000" stroke-width="1"/><path d="M12,12l10,-4q-1,-1,-2.5,-1l-10,4v2l10,4q1.5,0,2.5,-1z" fill="#000"/><path d="M24,12h${this.svgWidth - 24}" fill="none" stroke="#000" stroke-width="2" stroke-dasharray="2"/>`;
                this.svgContent += `<g transform="translate(0,${this.svgHeight})">${path}</g>`;
                return this.lf();
            },
            // underline text:
            ul() {
                this.textAttributes['text-decoration'] = 'underline';
                return '';
            },
            // emphasize text:
            em() {
                this.textAttributes.stroke = '#000';
                return '';
            },
            // invert text:
            iv() {
                this.textAttributes.filter = 'url(#receiptinvert)';
                return '';
            },
            // scale up text:
            wh(wh) {
                const w = wh < 2 ? wh + 1 : wh - 1;
                const h = wh < 3 ? wh : wh - 1;
                this.textAttributes.transform = `scale(${w},${h})`;
                this.lineHeight = Math.max(this.lineHeight, h);
                this.textScale = w;
                return '';
            },
            // cancel text decoration:
            normal() {
                this.textAttributes = {};
                this.textScale = 1;
                return '';
            },
            // print text:
            text(text, encoding) {
                let p = this.textPosition;
                const tspan = this.arrayFrom(text, encoding).reduce((a, c) => {
                    const q = this.measureText(c, encoding) * this.textScale;
                    const r = (p + q / 2) * this.charWidth / this.textScale;
                    p += q;
                    return a + `<tspan x="${r}">${c.replace(/[ &<>]/g, r => ({' ': '&#xa0;', '&': '&amp;', '<': '&lt;', '>': '&gt;'}[r]))}</tspan>`;
                }, '');
                const attr = Object.keys(this.textAttributes).reduce((a, key) => a + ` ${key}="${this.textAttributes[key]}"`, '');
                this.textElement += `<text${attr}>${tspan}</text>`;
                this.textPosition += this.measureText(text, encoding) * this.textScale;
                return '';
            },
            // feed new line:
            lf() {
                const h = this.lineHeight * this.charWidth * 2;
                if (this.textElement.length > 0) {
                    this.svgContent += `<g transform="translate(${this.lineMargin * this.charWidth},${this.svgHeight + h})">${this.textElement}</g>`;
                }
                this.svgHeight += Math.max(h, this.feedMinimum);
                this.lineHeight = 1;
                this.textElement = '';
                this.textPosition = 0;
                return '';
            },
            // insert commands:
            command(command) {
                return '';
            },
            // print image:
            image(image) {
                const png = typeof window !== 'undefined' ? window.atob(image) : Buffer.from(image, 'base64').toString('binary');
                let imgWidth = 0;
                let imgHeight = 0;
                png.replace(/^\x89PNG\x0d\x0a\x1a\x0a\x00\x00\x00\x0dIHDR(.{4})(.{4})/, (match, w, h) => {
                    imgWidth = w.charCodeAt(0) << 24 | w.charCodeAt(1) << 16 | w.charCodeAt(2) << 8 | w.charCodeAt(3);
                    imgHeight = h.charCodeAt(0) << 24 | h.charCodeAt(1) << 16 | h.charCodeAt(2) << 8 | h.charCodeAt(3);
                    return '';
                });
                const imgData = `<image xlink:href="data:image/png;base64,${image}" x="0" y="0" width="${imgWidth}" height="${imgHeight}"/>`;
                const margin = this.lineMargin * this.charWidth + (this.lineWidth * this.charWidth - imgWidth) * this.lineAlign / 2;
                this.svgContent += `<g transform="translate(${margin},${this.svgHeight})">${imgData}</g>`;
                this.svgHeight += imgHeight;
                return '';
            },
            // print QR Code:
            qrcode(symbol, encoding) {
                if (typeof qrcode !== 'undefined' && symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    qr.createSvgTag(symbol.cell, 0).replace(/width="(\d+)px".*height="(\d+)px".*(<path.*?>)/, (match, w, h, path) => {
                        const margin = this.lineMargin * this.charWidth + (this.lineWidth * this.charWidth - Number(w)) * this.lineAlign / 2;
                        this.svgContent += `<g transform="translate(${margin},${this.svgHeight})">${path}</g>`;
                        this.svgHeight += Number(h);
                    });
                }
                return '';
            },
            // print barcode:
            barcode(symbol, encoding) {
                const bar = barcode.generate(symbol);
                const h = bar.height;
                if ('length' in bar) {
                    const width = bar.length;
                    const height = h + (bar.hri ? this.charWidth * 2 + 2 : 0);
                    // draw barcode
                    let path = `<path d="`;
                    bar.widths.reduce((p, w, i) => {
                        if (i % 2 === 1) {
                            path += `M${p},${0}h${w}v${h}h${-w}z`;
                        }
                        return p + w;
                    }, 0);
                    path += '" fill="#000"/>';
                    // draw human readable interpretation
                    if (bar.hri) {
                        const m = (width - (bar.text.length - 1) * this.charWidth) / 2;
                        const tspan = bar.text.split('').reduce((a, c, i) => a + `<tspan x="${m + this.charWidth * i}">${c.replace(/[ &<>]/g, r => ({' ': '&#xa0;', '&': '&amp;', '<': '&lt;', '>': '&gt;'}[r]))}</tspan>`, '');
                        path += `<text y="${height}">${tspan}</text>`;
                    }
                    const margin = this.lineMargin * this.charWidth + (this.lineWidth * this.charWidth - width) * this.lineAlign / 2;
                    this.svgContent += `<g transform="translate(${margin},${this.svgHeight})">${path}</g>`;
                    this.svgHeight += height;
                }
                return '';
            }
        };
    
        //
        // Plain Text
        //
        const _text = {
            left: 0,
            width: 48,
            position: 0,
            scale: 1,
            buffer: [],
            // start printing:
            open(printer) {
                this.left = 0;
                this.width = printer.cpl;
                this.position = 0;
                this.scale = 1;
                this.buffer = [];
                return '';
            },
            // set print area:
            area(left, width, right) {
                this.left = left;
                this.width = width;
                return '';
            },
            // set absolute print position:
            absolute(position) {
                this.position = position;
                return '';
            },
            // set relative print position:
            relative(position) {
                this.position += Math.round(position);
                return '';
            },
            // print horizontal rule:
            hr(width) {
                return ' '.repeat(this.left) + '-'.repeat(width);
            },
            // print vertical rules:
            vr(widths, height) {
                this.buffer.push({ data: '|', index: this.position, length: 1 });
                widths.forEach(w => {
                    this.position += w + 1;
                    this.buffer.push({ data: '|', index: this.position, length: 1 });
                });
                return '';
            },
            // start rules:
            vrstart(widths) {
                return ' '.repeat(this.left) + widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
            },
            // stop rules:
            vrstop(widths) {
                return ' '.repeat(this.left) + widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
            },
            // print vertical and horizontal rules:
            vrhr(widths1, widths2, dl, dr) {
                const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(dr, 0));
                const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(-dr, 0));
                return ' '.repeat(this.left) + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
            },
            // ruled line composition
            vrtable: {
                ' ' : { ' ' : ' ', '+' : '+', '-' : '-' },
                '+' : { ' ' : '+', '+' : '+', '-' : '+' },
                '-' : { ' ' : '-', '+' : '+', '-' : '-' }
            },
            // set line spacing and feed new line:
            vrlf(vr) {
                return this.lf();
            },
            // scale up text:
            wh(wh) {
                const w = wh < 2 ? wh + 1 : wh - 1;
                this.scale = w;
                return '';
            },
            // cancel text decoration:
            normal() {
                this.scale = 1;
                return '';
            },
            // print text:
            text(text, encoding) {
                const d = this.arrayFrom(text, encoding).reduce((a, c) => a + c + ' '.repeat(this.measureText(c, encoding) * (this.scale - 1)), '');
                const l = this.measureText(text, encoding) * this.scale;
                this.buffer.push({ data: d, index: this.position, length: l });
                this.position += l;
                return '';
            },
            // feed new line:
            lf() {
                let r = '';
                if (this.buffer.length > 0) {
                    let p = 0;
                    r += this.buffer.sort((a, b) => a.index - b.index).reduce((a, c) => {
                        const s = a + ' '.repeat(c.index - p) + c.data;
                        p = c.index + c.length;
                        return s;
                    }, ' '.repeat(this.left));
                }
                r += '\n';
                this.position = 0;
                this.buffer = [];
                return r;
            }
        };
    
        const Base64PNG = {
            async from(svg, options = {}) {
                const c = commands.svg.charWidth;
                const m = options.margin * c || 0;
                const n = options.marginRight * c || 0;
                const img = new Image();
                img.src = 'data:image/svg+xml,' + encodeURIComponent(svg);
                await img.decode();
                const w = img.width;
                const h = img.height;
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                if (options.landscape) {
                    canvas.width = h;
                    canvas.height = w + m + n;
                    context.translate(0, w + n);
                    context.rotate(-Math.PI / 2);
                }
                else {
                    canvas.width = w;
                    canvas.height = h;
                }
                context.drawImage(img, 0, 0);
                return canvas.toDataURL('png');
            }
        };
    
        const commands = {
            base: { ..._base },
            svg: { ..._base, ..._svg },
            text: { ..._base, ..._text }
        };
    
        const encoding = {
            'ja': 'shiftjis', 'ko': 'ksc5601', 'zh': 'gb18030', 'zh-hans': 'gb18030', 'zh-hant': 'big5', 'th': 'tis620'
        };
    
        const parseOption = options => {
            // parameters
            const params = {
                p: '', // printer control language
                c: '-1', // characters per line
                u: false, // upside down
                v: false, // landscape orientation
                r: '-1', // print resolution for -v
                s: false, // paper saving
                n: false, // no paper cut
                m: '-1,-1', // print margin
                i: false, // print as image
                b: '-1', // image thresholding
                g: '-1', // image gamma correction
                l: new Intl.NumberFormat().resolvedOptions().locale // language of source file
            };
            // arguments
            const argv = options ? options.split(' ') : [];
            // parse arguments
            for (let i = 0; i < argv.length; i++) {
                const key = argv[i];
                if (/^-[uvsni]$/.test(key)) {
                    // option without value
                    params[key[1]] = true;
                }
                else if (/^-[pcrmbgl]$/.test(key)) {
                    // option with value
                    if (i < argv.length - 1) {
                        const value = argv[i + 1];
                        if (/^[^-]/.test(value)) {
                            params[key[1]] = value;
                            i++;
                        }
                    }
                }
                else {
                    // undefined option
                }
            }
            // language
            let l = params.l.toLowerCase();
            l = l.slice(0, /^zh-han[st]/.test(l) ? 7 : 2);
            // printer control language
            let p = params.p.toLowerCase();
            if (!/^(escpos|epson|sii|citizen|fit|impactb?|generic|star(line|graphic|impact[23]?)?|emustarline)$/.test(p)) {
                p = 'base';
            }
            else if (/^(emu)?star(line)?$/.test(p)) {
                p += `${/^(ja|ko|zh)/.test(l) ? 'm' : 's'}bcs${/^(ko|zh)/.test(l) ? '2' : ''}`;
            }
            // string to number
            const c = Number(params.c);
            const m = params.m.split(',').map(c => Number(c));
            const r = Number(params.r);
            const b = Number(params.b);
            const g = Number(params.g);
            // options
            return {
                asImage: params.i,
                landscape: params.v,
                resolution: r === 180 ? r : 203,
                cpl: c >= 24 && c <= 96 ? Math.trunc(c) : 48,
                encoding: encoding[l] || 'multilingual',
                gradient: !(b >= 0 && b <= 255),
                gamma: g >= 0.1 && g <= 10.0 ? g : 1.0,
                threshold: b >= 0 && b <= 255 ? Math.trunc(b) : 128,
                upsideDown: params.u,
                spacing: !params.s,
                cutting: !params.n,
                margin: m[0] >= 0 && m[0] <= 24 ? Math.trunc(m[0]) : 0,
                marginRight: m[1] >= 0 && m[1] <= 24 ? Math.trunc(m[1]) : 0,
                command: p
            };
        };
    
        return {
            /**
             * Barcode generator.
             * @type {object} barcode generator
             */
            barcode: barcode,
            /**
             * Command objects.
             * @type {object} command objects
             */
            commands: commands,
            /**
             * Create instance.
             * @param {string} markdown receipt markdown
             * @param {string} [options] conversion options
             * @returns {object} new instance
             */
            from(markdown, options) {
                // parse options
                const params = parseOption(options);
                // create instance
                return {
                    /**
                     * Return string representing this object.
                     * @returns {string} receipt markdown
                     */
                    toString() {
                        return markdown;
                    },
                    /**
                     * Convert receipt markdown to text.
                     * @returns {string} text
                     */
                    async toText() {
                        return await transform(markdown, { ...params, ...{ command: commands.text } });
                    },
                    /**
                     * Convert receipt markdown to SVG.
                     * @returns {string} SVG
                     */
                    async toSVG() {
                        return await transform(markdown, { ...params, ...{ command: commands.svg } });
                    },
                    /**
                     * Convert receipt markdown to PNG.
                     * @returns {string} PNG as data URL
                     */
                    async toPNG() {
                        return await Base64PNG.from(await this.toSVG());
                    },
                    /**
                     * Convert receipt markdown to printer commands.
                     * @returns {string} printer commands
                     */
                    async toCommand() {
                        // printer control language
                        let p = params.command;
                        // print as image
                        if (params.asImage) {
                            const r90 = params.landscape ? { cpl: 48, margin: 0, marginRight: 0 } : {};
                            const png = await Base64PNG.from(await this.toSVG(), params);
                            return await transform(`|{i:${png.replace(/^data:.*,/, '')}}`, { ...params, ...r90, ...{ command: ReceiptPrinter.create(p) } });
                        }
                        // print with device font
                        if (params.landscape && /^(escpos|epson|sii|citizen|star[sm]bcs2?)$/.test(p)) {
                            p += '90';
                        }
                        // convert markdown to command
                        return await transform(markdown, { ...params, ...{ command: ReceiptPrinter.create(p) } });
                    }
                };
            }
        };
    })();
  </script>
  <script tpe="text/javascript">
    /*
Copyright 2024 Open Foodservice System Consortium

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// QR Code is a registered trademark of DENSO WAVE INCORPORATED.

const ReceiptPrinter = (() => {
    //
    // Buffer
    //
    const Buffer = {
        from(image) {
            return {
                toString() {
                    return image;
                }
            }
        }
    };

    //
    // iconv
    //
    const iconv = (() => {
        // shiftjis table
        const sjistable = { '\u00a5': 0x5c, '\u203e': 0x7e, '\u301c': 0x8160 };
        const sjisdecoder = new TextDecoder('shift-jis');
        for (let i = 0x81; i <= 0xfc; i++) {
            if (i <= 0x84 || i >= 0x87 && i <= 0x9f || i >= 0xe0 && i <= 0xea || i >= 0xed && i <= 0xee || i >= 0xfa) {
                for (let j = 0x40; j <= 0xfc; j++) {
                    const c = sjisdecoder.decode(new Uint8Array([i, j]));
                    if (c.length === 1 && c !== '\ufffd' && !sjistable[c]) {
                        sjistable[c] = i << 8 | j;
                    }
                }
            }
        }
        // shiftjis converter
        const shiftjis = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else if (c >= 0xff61 && c <= 0xff9f) {
                    r += String.fromCodePoint(c - 0xfec0);
                }
                else {
                    const d = sjistable[String.fromCodePoint(c)] || 0x3f;
                    if (d > 0xff) {
                        r += String.fromCodePoint(d >> 8 & 0xff, d & 0xff);
                    }
                    else {
                        r += String.fromCodePoint(d);
                    }
                }
            }
            return r;
        };
        // ksc5601 table
        const kstable = {};
        const ksdecoder = new TextDecoder('euc-kr');
        for (let i = 0xa1; i <= 0xfd; i++) {
            if (i <= 0xac || i >= 0xb0 && i <= 0xc8 || i >= 0xca) {
                for (let j = 0xa1; j <= 0xfc; j++) {
                    const c = ksdecoder.decode(new Uint8Array([i, j]));
                    if (c.length === 1 && c !== '\ufffd' && !kstable[c]) {
                        kstable[c] = i << 8 | j;
                    }
                }
            }
        }
        // ksc5601 converter
        const ksc5601 = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else if (c >= 0xff61 && c <= 0xff9f) {
                    r += String.fromCodePoint(c - 0xfec0);
                }
                else {
                    const d = kstable[String.fromCodePoint(c)] || 0x3f;
                    if (d > 0xff) {
                        r += String.fromCodePoint(d >> 8 & 0xff, d & 0xff);
                    }
                    else {
                        r += String.fromCodePoint(d);
                    }
                }
            }
            return r;
        };
        // gb18030 table
        const gbtable = {};
        const gbdecoder = new TextDecoder('gb18030');
        // 1, 2
        for (let i = 0xa1; i <= 0xf7; i++) {
            if (i <= 0xa9 || i >= 0xb0) {
                for (let j = 0xa1; j <= 0xfe; j++) {
                    const c = gbdecoder.decode(new Uint8Array([i, j]));
                    if (c.length === 1 && c !== '\ufffd' && !gbtable[c]) {
                        gbtable[c] = i << 8 | j;
                    }
                }
            }
        }
        // 3
        for (let i = 0x81; i <= 0xa0; i++) {
            for (let j = 0x40; j <= 0xfe; j++) {
                const c = gbdecoder.decode(new Uint8Array([i, j]));
                if (c.length === 1 && c !== '\ufffd' && !gbtable[c]) {
                    gbtable[c] = i << 8 | j;
                }
            }
        }
        // 4, 5
        for (let i = 0xa8; i <= 0xfe; i++) {
            for (let j = 0x40; j <= 0xa0; j++) {
                const c = gbdecoder.decode(new Uint8Array([i, j]));
                if (c.length === 1 && c !== '\ufffd' && !gbtable[c]) {
                    gbtable[c] = i << 8 | j;
                }
            }
        }
        // CJK-A
        let f = 0x81, g = 0x39, h = 0xee;
        while (true) {
            for (let i = 0x30; i <= 0x39; i++) {
                if (!(f === 0x81 && g === 0x39 && h === 0xee && i < 0x39 || f === 0x82 && g === 0x35 && h === 0x87 && i > 0x38)) {
                    const c = gbdecoder.decode(new Uint8Array([f, g, h, i]));
                    if (c.length === 1 && c !== '\ufffd' && !gbtable[c]) {
                        gbtable[c] = f << 24 | g << 16 | h << 8 | i;
                    }
                }
            }
            h++;
            if (h > 0xfe) {
                h = 0x81;
                g++;
                if (g > 0x39) {
                    g = 0x30;
                    f++;
                }
            }
            if (f === 0x82 && g === 0x35 && h === 0x88) {
                break;
            }
        }
        // gb18030 converter
        const gb18030 = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else {
                    const d = gbtable[String.fromCodePoint(c)] || 0xa1a1;
                    if (d < 0 || d > 0xffff) {
                        r += String.fromCodePoint(d >> 24 & 0xff, d >> 16 & 0xff, d >> 8 & 0xff, d & 0xff);
                    }
                    else if (d > 0xff) {
                        r += String.fromCodePoint(d >> 8 & 0xff, d & 0xff);
                    }
                    else {
                        r += String.fromCodePoint(d);
                    }
                }
            }
            return r;
        };
        // big5 table
        const bigtable = {};
        const bigdecoder = new TextDecoder('big5');
        for (let i = 0xa1; i <= 0xf9; i++) {
            if (i <= 0xc6 || i >= 0xc9) {
                for (let j = 0x40; j <= 0x7e; j++) {
                    const c = bigdecoder.decode(new Uint8Array([i, j]));
                    if (c.length === 1 && c !== '\ufffd' && !bigtable[c]) {
                        bigtable[c] = i << 8 | j;
                    }
                }
                if (i !== 0xc6) {
                    for (let j = 0xa1; j <= 0xfe; j++) {
                        if (i !== 0xf9 || j <= 0xd5) {
                            const c = bigdecoder.decode(new Uint8Array([i, j]));
                            if (c.length === 1 && c !== '\ufffd' && !bigtable[c]) {
                                bigtable[c] = i << 8 | j;
                            }
                        }
                    }
                }
            }
        }
        // big5 converter
        const big5 = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else {
                    const d = bigtable[String.fromCodePoint(c)] || 0x3f;
                    if (d > 0xff) {
                        r += String.fromCodePoint(d >> 8 & 0xff, d & 0xff);
                    }
                    else {
                        r += String.fromCodePoint(d);
                    }
                }
            }
            return r;
        };
        // tis620 converter
        const tis620 = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else if (c >= 0xe01 && c <= 0xe7f) {
                    r += String.fromCodePoint(c - 0xd60);
                }
                else {
                    r += '?';
                }
            }
            return r;
        };
        // ascii converter
        const ascii = content => {
            let r = '';
            for (let i = 0; i < content.length; i++) {
                const c = content.codePointAt(i);
                if (c > 0xffff) {
                    i++;
                }
                if (c < 0x80) {
                    r += String.fromCodePoint(c);
                }
                else {
                    r += '?';
                }
            }
            return r;
        };
        return {
            encode(content, encoding) {
                let r = '';
                switch (encoding) {
                    case 'cp932':
                    case 'shiftjis':
                        r = shiftjis(content);
                        break;
                    case 'cp936':
                    case 'gb18030':
                        r = gb18030(content);
                        break;
                    case 'cp949':
                    case 'ksc5601':
                        r = ksc5601(content);
                        break;
                    case 'cp950':
                    case 'big5':
                        r = big5(content);
                        break;
                    case 'tis620':
                        r = tis620(content);
                        break;
                    default:
                        r = ascii(content);
                        break;
                }
                return Buffer.from(r);
            }
        };
    })();

    //
    // PNG
    //
    const PNG = {
        async read(buffer) {
            const img = new Image();
            img.src = 'data:image/png;base64,' + buffer.toString();
            await img.decode();
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = img.width;
            canvas.height = img.height;
            context.drawImage(img, 0, 0);
            return context.getImageData(0, 0, canvas.width, canvas.height);
        }
    };

    // shortcut
    const $ = String.fromCharCode;

    //
    // multilingual conversion table (cp437, cp852, cp858, cp866, cp1252)
    //
    const multitable = {};
    const multipage = {
        '\x00': 'ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ',
        '\x10': '€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ',
        '\x11': 'АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ ',
        '\x12': 'ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ ',
        '\x13': 'ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ '
    };
    const starpage = { '\x00': '\x01', '\x10': '\x20', '\x11': '\x0a', '\x12': '\x05', '\x13': '\x04' };
    for (let p of Object.keys(multipage)) {
        const s = multipage[p];
        for (let i = 0; i < 128; i++) {
            const c = s[i];
            if (!multitable[c]) {
                multitable[c] = p + $(i + 128);
            }
        }
    }

    //
    // ESC/POS Common
    //
    const _escpos = {
        // printer configuration
        upsideDown: false,
        spacing: false,
        cutting: true,
        gradient: true,
        gamma: 1.8,
        threshold: 128,
        // ruled line composition
        vrtable: {
            ' '    : { ' ' : ' ',    '\x90' : '\x90', '\x95' : '\x95', '\x9a' : '\x9a', '\x9b' : '\x9b', '\x9e' : '\x9e', '\x9f' : '\x9f' },
            '\x91' : { ' ' : '\x91', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x8f', '\x9e' : '\x8f', '\x9f' : '\x8f' },
            '\x95' : { ' ' : '\x95', '\x90' : '\x90', '\x95' : '\x95', '\x9a' : '\x90', '\x9b' : '\x90', '\x9e' : '\x90', '\x9f' : '\x90' },
            '\x98' : { ' ' : '\x98', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x93', '\x9b' : '\x8f', '\x9e' : '\x93', '\x9f' : '\x8f' },
            '\x99' : { ' ' : '\x99', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x92', '\x9e' : '\x8f', '\x9f' : '\x92' },
            '\x9c' : { ' ' : '\x9c', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x93', '\x9b' : '\x8f', '\x9e' : '\x93', '\x9f' : '\x8f' },
            '\x9d' : { ' ' : '\x9d', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x92', '\x9e' : '\x8f', '\x9f' : '\x92' }
        },
        // codepages: (ESC t n) (FS &) (FS C n) (ESC R n)
        codepage: {
            cp437: '\x1bt\x00', cp852: '\x1bt\x12', cp858: '\x1bt\x13', cp860: '\x1bt\x03',
            cp863: '\x1bt\x04', cp865: '\x1bt\x05', cp866: '\x1bt\x11', cp1252: '\x1bt\x10',
            cp932: '\x1bt\x01\x1cC1\x1bR\x08', cp936: '\x1bt\x00\x1c&',
            cp949: '\x1bt\x00\x1c&\x1bR\x0d', cp950: '\x1bt\x00\x1c&',
            shiftjis: '\x1bt\x01\x1cC1\x1bR\x08', gb18030: '\x1bt\x00\x1c&',
            ksc5601: '\x1bt\x00\x1c&\x1bR\x0d', big5: '\x1bt\x00\x1c&', tis620: '\x1bt\x15'
        },
        // convert to multiple codepage characters: (ESC t n)
        multiconv(text) {
            let p = '', r = '';
            for (let i = 0; i < text.length; i++) {
                const c = text[i];
                if (c > '\x7f') {
                    const d = multitable[c];
                    if (d) {
                        const q = d[0];
                        if (p === q) {
                            r += d[1];
                        }
                        else {
                            r += '\x1bt' + d;
                            p = q;
                        }
                    }
                    else {
                        r += '?';
                    }
                }
                else {
                    r += c;
                }
            }
            return r;
        }
    };

    //
    // ESC/POS Thermal
    //
    const _thermal = {
        alignment: 0,
        left: 0,
        width: 48,
        right: 0,
        margin: 0,
        marginRight: 0,
        // start printing: ESC @ GS a n ESC M n FS ( A pL pH fn m ESC SP n FS S n1 n2 (ESC 2) (ESC 3 n) ESC { n FS .
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            return '\x1b@\x1da\x00\x1bM' + (printer.encoding === 'tis620' ? 'a' : '0') + '\x1c(A' + $(2, 0, 48, 0) + '\x1b \x00\x1cS\x00\x00' + (this.spacing ? '\x1b2' : '\x1b3\x00') + '\x1b{' + $(this.upsideDown) + '\x1c.';
        },
        // finish printing: GS r n
        close() {
            return (this.cutting ? this.cut() : '') + '\x1dr1';
        },
        // set print area: GS L nL nH GS W nL nH
        area(left, width, right) {
            this.left = left;
            this.width = width;
            this.right = right;
            const m = (this.margin + left) * this.charWidth;
            const w = width * this.charWidth;
            return '\x1dL' + $(m & 255, m >> 8 & 255) + '\x1dW' + $(w & 255, w >> 8 & 255);
        },
        // set line alignment: ESC a n
        align(align) {
            this.alignment = align;
            return '\x1ba' + $(align);
        },
        // set absolute print position: ESC $ nL nH
        absolute(position) {
            const p = position * this.charWidth;
            return '\x1b$' + $(p & 255, p >> 8 & 255);
        },
        // set relative print position: ESC \ nL nH
        relative(position) {
            const p = position * this.charWidth;
            return '\x1b\\' + $(p & 255, p >> 8 & 255);
        },
        // print horizontal rule: FS C n FS . ESC t n ...
        hr(width) {
            return '\x1cC0\x1c.\x1bt\x01' + '\x95'.repeat(width);
        },
        // print vertical rules: GS ! n FS C n FS . ESC t n ...
        vr(widths, height) {
            return widths.reduce((a, w) => a + this.relative(w) + '\x96', '\x1d!' + $(height - 1) + '\x1cC0\x1c.\x1bt\x01\x96');
        },
        // start rules: FS C n FS . ESC t n ...
        vrstart(widths) {
            return '\x1cC0\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
        },
        // stop rules: FS C n FS . ESC t n ...
        vrstop(widths) {
            return '\x1cC0\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
        },
        // print vertical and horizontal rules: FS C n FS . ESC t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            return '\x1cC0\x1c.\x1bt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // set line spacing and feed new line: (ESC 2) (ESC 3 n)
        vrlf(vr) {
            return (vr === this.upsideDown && this.spacing ? '\x1b2' : '\x1b3\x00') + this.lf();
        },
        // cut paper: GS V m n
        cut() {
            return '\x1dVB\x00';
        },
        // underline text: ESC - n FS - n
        ul() {
            return '\x1b-2\x1c-2';
        },
        // emphasize text: ESC E n
        em() {
            return '\x1bE1';
        },
        // invert text: GS B n
        iv() {
            return '\x1dB1';
        },
        // scale up text: GS ! n
        wh(wh) {
            return '\x1d!' + (wh < 3 ? $((wh & 1) << 4 | wh >> 1 & 1) : $(wh - 2 << 4 | wh - 2));
        },
        // cancel text decoration: ESC - n FS - n ESC E n GS B n GS ! n
        normal() {
            return '\x1b-0\x1c-0\x1bE0\x1dB0\x1d!\x00';
        },
        // print text:
        text(text, encoding) {
            switch (encoding) {
                case 'multilingual':
                    return this.multiconv(text);
                case 'tis620':
                    return this.codepage[encoding] + this.arrayFrom(text, encoding).reduce((a, c) => a + '\x00' + iconv.encode(c, encoding).toString('binary'), '');
                default:
                    return this.codepage[encoding] + iconv.encode(text, encoding).toString('binary');
            }
        },
        // feed new line: LF
        lf() {
            return '\x0a';
        },
        // insert commands:
        command(command) {
            return command;
        },
        // image split size
        split: 512,
        // print image: GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk GS ( L pL pH m fn
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const right = arguments[4] || this.right;
            let r = this.upsideDown ? this.area(right + this.marginRight - this.margin, width, left) + this.align(2 - align) : '';
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            let j = this.upsideDown ? img.data.length - 4 : 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += this.upsideDown ? -4 : 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
                r += '\x1d(L' + $(2, 0, 48, 50);
            }
            return r;
        },
        // print QR Code: GS ( k pL pH cn fn n1 n2 GS ( k pL pH cn fn n GS ( k pL pH cn fn n GS ( k pL pH cn fn m d1 ... dk GS ( k pL pH cn fn m
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = this.upsideDown ? this.area(this.right + this.marginRight - this.margin, this.width, this.left) + this.align(2 - this.alignment) : '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    let img = qr.createASCII(2, 0);
                    if (this.upsideDown) {
                        img = img.split('').reverse().join('');
                    }
                    img = img.split('\n');
                    const w = img.length * symbol.cell;
                    const h = w;
                    const l = (w + 7 >> 3) * h + 10;
                    r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            r += d;
                        }
                    }
                    r += '\x1d(L' + $(2, 0, 48, 50);
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return d.length > 0 ? '\x1d(k' + $(4, 0, 49, 65, 50, 0) + '\x1d(k' + $(3, 0, 49, 67, symbol.cell) + '\x1d(k' + $(3, 0, 49, 69, this.qrlevel[symbol.level]) + '\x1d(k' + $(d.length + 3 & 255, d.length + 3 >> 8 & 255, 49, 80, 48) + d + '\x1d(k' + $(3, 0, 49, 81, 48) : '';
            }
        },
        // QR Code error correction level:
        qrlevel: {
            l: 48, m: 49, q: 50, h: 51
        },
        // print barcode: GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
            const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
            switch (b) {
                case this.bartype.ean:
                    d = d.slice(0, 12);
                    break;
                case this.bartype.upc:
                    d = d.slice(0, 11);
                    break;
                case this.bartype.ean + 1:
                    d = d.slice(0, 7);
                    break;
                case this.bartype.upc + 1:
                    d = this.upce(d);
                    break;
                case this.bartype.code128:
                    d = this.code128(d);
                    break;
                default:
                    break;
            }
            d = d.slice(0, 255);
            return d.length > 0 ? '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d : '';
        },
        // barcode types:
        bartype: {
            upc: 65, ean: 67, jan: 67, code39: 69, itf: 70, codabar: 71, nw7: 71, code93: 72, code128: 73
        },
        // generate UPC-E data (convert UPC-E to UPC-A):
        upce(data) {
            let r = '';
            let s = data.replace(/((?!^0\d{6,7}$).)*/, '');
            if (s.length > 0) {
                r += s.slice(0, 3);
                switch (s[6]) {
                    case '0': case '1': case '2':
                        r += s[6] + '0000' + s[3] + s[4] + s[5];
                        break;
                    case '3':
                        r += s[3] + '00000' + s[4] + s[5];
                        break;
                    case '4':
                        r += s[3] + s[4] + '00000' + s[5];
                        break;
                    default:
                        r += s[3] + s[4] + s[5] + '0000' + s[6];
                        break;
                }
            }
            return r;
        },
        // CODE128 special characters:
        c128: {
            special: 123, codea: 65, codeb: 66, codec: 67, shift: 83
        },
        // generate CODE128 data (minimize symbol width):
        code128(data) {
            let r = '';
            let s = data.replace(/((?!^[\x00-\x7f]+$).)*/, '').replace(/{/g, '{{');
            if (s.length > 0) {
                const d = [];
                const p = s.search(/[^ -_]/);
                if (/^\d{2}$/.test(s)) {
                    d.push(this.c128.special, this.c128.codec, Number(s));
                }
                else if (/^\d{4,}/.test(s)) {
                    this.code128c(this.c128.codec, s, d);
                }
                else if (p >= 0 && s.charCodeAt(p) < 32) {
                    this.code128a(this.c128.codea, s, d);
                }
                else if (s.length > 0) {
                    this.code128b(this.c128.codeb, s, d);
                }
                else {
                    // end
                }
                r = d.reduce((a, c) => a + $(c), '');
            }
            return r;
        },
        // process CODE128 code set A:
        code128a(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(this.c128.special, x);
            }
            s = s.replace(/^((?!\d{4,})[\x00-_])+/, m => (m.split('').forEach(c => d.push(c.charCodeAt(0))), ''));
            s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push(m.charCodeAt(0)), ''));
            const t = s.slice(1);
            const p = t.search(/[^ -_]/);
            if (/^\d{4,}/.test(s)) {
                this.code128c(this.c128.codec, s, d);
            }
            else if (p >= 0 && t.charCodeAt(p) < 32) {
                d.push(this.c128.special, this.c128.shift, s.charCodeAt(0));
                this.code128a(this.c128.shift, t, d);
            }
            else if (s.length > 0) {
                this.code128b(this.c128.codeb, s, d);
            }
            else {
                // end
            }
        },
        // process CODE128 code set B:
        code128b(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(this.c128.special, x);
            }
            s = s.replace(/^((?!\d{4,})[ -\x7f])+/, m => (m.split('').forEach(c => d.push(c.charCodeAt(0))), ''));
            s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push(m.charCodeAt(0)), ''));
            const t = s.slice(1);
            const p = t.search(/[^ -_]/);
            if (/^\d{4,}/.test(s)) {
                this.code128c(this.c128.codec, s, d);
            }
            else if (p >= 0 && t.charCodeAt(p) > 95) {
                d.push(this.c128.special, this.c128.shift, s.charCodeAt(0));
                this.code128b(this.c128.shift, t, d);
            }
            else if (s.length > 0) {
                this.code128a(this.c128.codea, s, d);
            }
            else {
                // end
            }
        },
        // process CODE128 code set C:
        code128c(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(this.c128.special, x);
            }
            s = s.replace(/^\d{4,}/g, m => m.replace(/\d{2}/g, c => (d.push(Number(c)), '')));
            const p = s.search(/[^ -_]/);
            if (p >= 0 && s.charCodeAt(p) < 32) {
                this.code128a(this.c128.codea, s, d);
            }
            else if (s.length > 0) {
                this.code128b(this.c128.codeb, s, d);
            }
            else {
                // end
            }
        }
    };

    //
    // SII
    //
    const _sii = {
        // start printing: ESC @ GS a n ESC M n ESC SP n FS S n1 n2 (ESC 2) (ESC 3 n) ESC { n FS .
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            return '\x1b@\x1da\x00\x1bM0\x1b \x00\x1cS\x00\x00' + (this.spacing ? '\x1b2' : '\x1b3\x00') + '\x1b{' + $(this.upsideDown) + '\x1c.';
        },
        // finish printing: DC2 q n
        close() {
            return (this.cutting ? this.cut() : '') + '\x12q\x00';
        },
        // set print area: GS L nL nH GS W nL nH
        area(left, width, right) {
            this.left = left;
            this.width = width;
            this.right = right;
            const m = (this.upsideDown ? this.marginRight + right : this.margin + left) * this.charWidth;
            const w = width * this.charWidth;
            return '\x1dL' + $(m & 255, m >> 8 & 255) + '\x1dW' + $(w & 255, w >> 8 & 255);
        },
        // image split size
        split: 1662,
        // print image: GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk GS ( L pL pH m fn
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const right = arguments[4] || this.right;
            let r = this.upsideDown ? this.area(right, width, left) + this.align(2 - align) : '';
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            let j = this.upsideDown ? img.data.length - 4 : 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += this.upsideDown ? -4 : 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
                r += '\x1d(L' + $(2, 0, 48, 50);
            }
            return r;
        },
        // print QR Code: DC2 ; n GS p 1 model e v mode nl nh dk
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = this.upsideDown ? this.area(this.right, this.width, this.left) + this.align(2 - this.alignment) : '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    let img = qr.createASCII(2, 0);
                    if (this.upsideDown) {
                        img = img.split('').reverse().join('');
                    }
                    img = img.split('\n');
                    const w = img.length * symbol.cell;
                    const h = w;
                    const l = (w + 7 >> 3) * h + 10;
                    r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            r += d;
                        }
                    }
                    r += '\x1d(L' + $(2, 0, 48, 50);
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return d.length > 0 ? '\x12;' + $(symbol.cell) + '\x1dp' + $(1, 2, this.qrlevel[symbol.level], 0, 77, d.length & 255, d.length >> 8 & 255) + d : '';
            }
        },
        // QR Code error correction levels:
        qrlevel: {
            l: 76, m: 77, q: 81, h: 72
        },
        // print barcode: GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
            const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
            switch (b) {
                case this.bartype.upc + 1:
                    d = this.upce(d);
                    break;
                case this.bartype.codabar:
                    d = this.codabar(d);
                    break;
                case this.bartype.code93:
                    d = this.code93(d);
                    break;
                case this.bartype.code128:
                    d = this.code128(d);
                    break;
                default:
                    break;
            }
            d = d.slice(0, 255);
            return d.length > 0 ? '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d : '';
        },
        // generate Codabar data:
        codabar(data) {
            return data.toUpperCase();
        },
        // CODE93 special characters:
        c93: {
            escape: 'cU,dA,dB,dC,dD,dE,dF,dG,dH,dI,dJ,dK,dL,dM,dN,dO,dP,dQ,dR,dS,dT,dU,dV,dW,dX,dY,dZ,cA,cB,cC,cD,cE, ,sA,sB,sC,$,%,sF,sG,sH,sI,sJ,+,sL,-,.,/,0,1,2,3,4,5,6,7,8,9,sZ,cF,cG,cH,cI,cJ,cV,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,cK,cL,cM,cN,cO,cW,pA,pB,pC,pD,pE,pF,pG,pH,pI,pJ,pK,pL,pM,pN,pO,pP,pQ,pR,pS,pT,pU,pV,pW,pX,pY,pZ,cP,cQ,cR,cS,cT'.split(','),
            code: '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ-. $/+%dcsp'.split('').reduce((a, c, i) => (a[c] = i, a), {}),
            start: 47, stop: 48
        },
        // generate CODE93 data:
        code93(data) {
            let r = '';
            let s = data.replace(/((?!^[\x00-\x7f]+$).)*/, '');
            if (s.length > 0) {
                const d = s.split('').reduce((a, c) => a + this.c93.escape[c.charCodeAt(0)], '').split('').map(c => this.c93.code[c]);
                d.push(this.c93.stop);
                r = d.reduce((a, c) => a + $(c), '');
            }
            return r;
        },
        // CODE128 special characters:
        c128: {
            starta: 103, startb: 104, startc: 105, atob: 100, atoc: 99, btoa: 101, btoc: 99, ctoa: 101, ctob: 100, shift: 98, stop: 105
        },
        // generate CODE128 data (minimize symbol width):
        code128(data) {
            let r = '';
            let s = data.replace(/((?!^[\x00-\x7f]+$).)*/, '');
            if (s.length > 0) {
                const d = [];
                const p = s.search(/[^ -_]/);
                if (/^\d{2}$/.test(s)) {
                    d.push(this.c128.startc, Number(s));
                }
                else if (/^\d{4,}/.test(s)) {
                    this.code128c(this.c128.startc, s, d);
                }
                else if (p >= 0 && s.charCodeAt(p) < 32) {
                    this.code128a(this.c128.starta, s, d);
                }
                else if (s.length > 0) {
                    this.code128b(this.c128.startb, s, d);
                }
                else {
                    // end
                }
                d.push(this.c128.stop);
                r = d.reduce((a, c) => a + $(c), '');
            }
            return r;
        },
        // process CODE128 code set A:
        code128a(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(x);
            }
            s = s.replace(/^((?!\d{4,})[\x00-_])+/, m => (m.split('').forEach(c => d.push((c.charCodeAt(0) + 64) % 96)), ''));
            s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push((m.charCodeAt(0) + 64) % 96), ''));
            const t = s.slice(1);
            const p = t.search(/[^ -_]/);
            if (/^\d{4,}/.test(s)) {
                this.code128c(this.c128.atoc, s, d);
            }
            else if (p >= 0 && t.charCodeAt(p) < 32) {
                d.push(this.c128.shift, s.charCodeAt(0) - 32);
                this.code128a(this.c128.shift, t, d);
            }
            else if (s.length > 0) {
                this.code128b(this.c128.atob, s, d);
            }
            else {
                // end
            }
        },
        // process CODE128 code set B:
        code128b(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(x);
            }
            s = s.replace(/^((?!\d{4,})[ -\x7f])+/, m => (m.split('').forEach(c => d.push(c.charCodeAt(0) - 32)), ''));
            s = s.replace(/^\d(?=(\d\d){2,}(\D|$))/, m => (d.push(m.charCodeAt(0) - 32), ''));
            const t = s.slice(1);
            const p = t.search(/[^ -_]/);
            if (/^\d{4,}/.test(s)) {
                this.code128c(this.c128.btoc, s, d);
            }
            else if (p >= 0 && t.charCodeAt(p) > 95) {
                d.push(this.c128.shift, s.charCodeAt(0) + 64);
                this.code128b(this.c128.shift, t, d);
            }
            else if (s.length > 0) {
                this.code128a(this.c128.btoa, s, d);
            }
            else {
                // end
            }
        },
        // process CODE128 code set c:
        code128c(x, s, d) {
            if (x !== this.c128.shift) {
                d.push(x);
            }
            s = s.replace(/^\d{4,}/g, m => m.replace(/\d{2}/g, c => (d.push(Number(c)), '')));
            const p = s.search(/[^ -_]/);
            if (p >= 0 && s.charCodeAt(p) < 32) {
                this.code128a(this.c128.ctoa, s, d);
            }
            else if (s.length > 0) {
                this.code128b(this.c128.ctob, s, d);
            }
            else {
                // end
            }
        }
    };

    //
    // Citizen
    //
    const _citizen = {
        // image split size
        split: 1662,
        // print barcode: GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
            const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
            switch (b) {
                case this.bartype.ean:
                    d = d.slice(0, 12);
                    break;
                case this.bartype.upc:
                    d = d.slice(0, 11);
                    break;
                case this.bartype.ean + 1:
                    d = d.slice(0, 7);
                    break;
                case this.bartype.upc + 1:
                    d = this.upce(d);
                    break;
                case this.bartype.codabar:
                    d = this.codabar(d);
                    break;
                case this.bartype.code128:
                    d = this.code128(d);
                    break;
                default:
                    break;
            }
            d = d.slice(0, 255);
            return d.length > 0 ? '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d : '';
        },
        // generate Codabar data:
        codabar(data) {
            return data.toUpperCase();
        }
    };

    //
    // Fujitsu Isotec
    //
    const _fit = {
        // image split size
        split: 1662,
        // print image: GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk GS ( L pL pH m fn
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const right = arguments[4] || this.right;
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            const s = [];
            let j = 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = (w + 7 >> 3) * h + 10;
                let r = '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
                r += '\x1d(L' + $(2, 0, 48, 50);
                s.push(r);
            }
            if (this.upsideDown) {
                s.reverse();
            }
            return (this.upsideDown && align === 2 ? this.area(right, width, left) : '') + s.join('');
        },
        // print QR Code: GS ( k pL pH cn fn n1 n2 GS ( k pL pH cn fn n GS ( k pL pH cn fn n GS ( k pL pH cn fn m d1 ... dk GS ( k pL pH cn fn m
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = this.upsideDown && this.alignment === 2 ? this.area(this.right, this.width, this.left) : '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    const img = qr.createASCII(2, 0).split('\n');
                    const w = img.length * symbol.cell;
                    const h = w;
                    const l = (w + 7 >> 3) * h + 10;
                    r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            r += d;
                        }
                    }
                    r += '\x1d(L' + $(2, 0, 48, 50);
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return d.length > 0 ? '\x1d(k' + $(4, 0, 49, 65, 50, 0) + '\x1d(k' + $(3, 0, 49, 67, symbol.cell) + '\x1d(k' + $(3, 0, 49, 69, this.qrlevel[symbol.level]) + '\x1d(k' + $(d.length + 3 & 255, d.length + 3 >> 8 & 255, 49, 80, 48) + d + '\x1d(k' + $(3, 0, 49, 81, 48) : '';
            }
        }
    };

    //
    // ESC/POS Impact
    //
    const _impact = {
        font: 0,
        style: 0,
        color: 0,
        left: 0,
        right: 0,
        position: 0,
        margin: 0,
        marginRight: 0,
        red: [],
        black: [],
        // start printing: ESC @ GS a n ESC M n (ESC 2) (ESC 3 n) ESC { n
        open(printer) {
            this.style = this.font;
            this.color = 0;
            this.left = 0;
            this.right = 0;
            this.position = 0;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            this.red = [];
            this.black = [];
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            return '\x1b@\x1da\x00\x1bM' + $(this.font) + (this.spacing ? '\x1b2' : '\x1b3\x12') + '\x1b{' + $(this.upsideDown) + '\x1c.';
        },
        // finish printing: GS r n
        close() {
            return (this.cutting ? this.cut() : '') + '\x1dr1';
        },
        // set print area:
        area(left, width, right) {
            this.left = this.margin + left;
            this.right = right + this.marginRight;
            return '';
        },
        // set line alignment: ESC a n
        align(align) {
            return '\x1ba' + $(align);
        },
        // set absolute print position:
        absolute(position) {
            this.position = position;
            return '';
        },
        // set relative print position:
        relative(position) {
            this.position += Math.round(position);
            return '';
        },
        // print horizontal rule: ESC t n ...
        hr(width) {
            return '\x1b!' + $(this.font) + ' '.repeat(this.left) + '\x1bt\x01' + '\x95'.repeat(width);
        },
        // print vertical rules: ESC ! n ESC t n ...
        vr(widths, height) {
            const d = '\x1b!' + $(this.font + (height > 1 ? 16 : 0)) + '\x1bt\x01\x96';
            this.black.push({ data: d, index: this.position, length: 1 });
            widths.forEach(w => {
                this.position += w + 1;
                this.black.push({ data: d, index: this.position, length: 1 });
            });
            return '';
        },
        // start rules: ESC ! n ESC t n ...
        vrstart(widths) {
            return '\x1b!' + $(this.font) + ' '.repeat(this.left) + '\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
        },
        // stop rules: ESC ! n ESC t n ...
        vrstop(widths) {
            return '\x1b!' + $(this.font) + ' '.repeat(this.left) + '\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
        },
        // print vertical and horizontal rules: ESC ! n ESC t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            return '\x1b!' + $(this.font) + ' '.repeat(this.left) + '\x1bt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // set line spacing and feed new line: (ESC 2) (ESC 3 n)
        vrlf(vr) {
            return (vr === this.upsideDown && this.spacing ? '\x1b2' : '\x1b3\x12') + this.lf();
        },
        // cut paper: GS V m n
        cut() {
            return '\x1dVB\x00';
        },
        // underline text:
        ul() {
            this.style += 128;
            return '';
        },
        // emphasize text:
        em() {
            this.style += 8;
            return '';
        },
        // invert text:
        iv() {
            this.color = 1;
            return '';
        },
        // scale up text:
        wh(wh) {
            if (wh > 0) {
                this.style += wh < 3 ? 64 >> wh : 48;
            }
            return '';
        },
        // cancel text decoration:
        normal() {
            this.style = this.font;
            this.color = 0;
            return '';
        },
        // print text:
        text(text, encoding) {
            const t = iconv.encode(text, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
            const d = '\x1b!' + $(this.style) + (encoding === 'multilingual' ? this.multiconv(text) : this.codepage[encoding] + iconv.encode(text, encoding).toString('binary'));
            const l = t.length * (this.style & 32 ? 2 : 1);
            if (this.color > 0) {
                this.red.push({ data: d, index: this.position, length: l });
            }
            else {
                this.black.push({ data: d, index: this.position, length: l });
            }
            this.position += l;
            return '';
        },
        // feed new line: LF
        lf() {
            let r = '';
            if (this.red.length > 0) {
                let p = 0;
                r += this.red.sort((a, b) => a.index - b.index).reduce((a, c) => {
                    const s = a + '\x1b!' + $(this.font) + ' '.repeat(c.index - p) + c.data;
                    p = c.index + c.length;
                    return s;
                }, '\x1br\x01\x1b!' + $(this.font) + ' '.repeat(this.left)) + '\x0d\x1br\x00';
            }
            if (this.black.length > 0) {
                let p = 0;
                r += this.black.sort((a, b) => a.index - b.index).reduce((a, c) => {
                    const s = a + '\x1b!' + $(this.font) + ' '.repeat(c.index - p) + c.data;
                    p = c.index + c.length;
                    return s;
                }, '\x1b!' + $(this.font) + ' '.repeat(this.left));
            }
            r += '\x0a';
            this.position = 0;
            this.red = [];
            this.black = [];
            return r;
        },
        // insert commands:
        command(command) {
            return command;
        },
        // print image: ESC * 0 wL wH d1 ... dk ESC J n
        async image(image) {
            let r = '';
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            if (w < 1024) {
                const d = Array(w).fill(0);
                let j = this.upsideDown ? img.data.length - 4 : 0;
                for (let y = 0; y < img.height; y += 8) {
                    const b = Array(w).fill(0);
                    const h = Math.min(8, img.height - y);
                    for (let p = 0; p < h; p++) {
                        let i = 0, e = 0;
                        for (let x = 0; x < w; x++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += this.upsideDown ? -4 : 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (this.upsideDown ? b[w - x - 1] |= 1 << p : b[x] |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    this.upsideDown ? b[w - x - 1] |= 1 << p : b[x] |= 128 >> p;
                                }
                            }
                        }
                    }
                    r += ' '.repeat(this.left) + '\x1b*\x00' + $(w & 255, w >> 8 & 255) + b.reduce((a, c) => a + $(c), '') + ' '.repeat(this.right) + '\x1bJ' + $(h * 2);
                }
            }
            return r;
        }
    };

    //
    // ESC/POS Impact Font B
    //
    const _fontb = {
        font: 1
    };

    //
    // StarPRNT Common
    //
    const _star = {
        // printer configuration
        upsideDown: false,
        spacing: false,
        cutting: true,
        gradient: true,
        gamma: 1.8,
        threshold: 128,
        margin: 0,
        // start printing: ESC @ ESC RS a n (ESC RS R n) ESC RS F n ESC SP n ESC s n1 n2 (ESC z n) (ESC 0) (SI) (DC2)
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.margin = printer.margin;
            return '\x1b@\x1b\x1ea\x00' + (printer.encoding === 'tis620' ? '\x1b\x1eR\x01': '') + '\x1b\x1eF\x00\x1b 0\x1bs00' + (this.spacing ? '\x1bz1' : '\x1b0') + (this.upsideDown ? '\x0f' : '\x12');
        },
        // finish printing: ESC GS ETX s n1 n2
        close() {
            return (this.cutting ? this.cut() : '') + '\x1b\x1d\x03\x01\x00\x00';
        },
        // set print area: ESC l n ESC Q n
        area(left, width, right) {
            return '\x1bl' + $(0) + '\x1bQ' + $(this.margin + left + width + right) + '\x1bl' + $(this.margin + left) + '\x1bQ' + $(this.margin + left + width);
        },
        // set line alignment: ESC GS a n
        align(align) {
            return '\x1b\x1da' + $(align);
        },
        // set absolute print position: ESC GS A n1 n2
        absolute(position) {
            const p = position * this.charWidth;
            return '\x1b\x1dA' + $(p & 255, p >> 8 & 255);
        },
        // set relative print position: ESC GS R n1 n2
        relative(position) {
            const p = position * this.charWidth;
            return '\x1b\x1dR' + $(p & 255, p >> 8 & 255);
        },
        // set line spacing and feed new line: (ESC z n) (ESC 0)
        vrlf(vr) {
            return (this.upsideDown ? this.lf() : '') + (vr === this.upsideDown && this.spacing ? '\x1bz1' : '\x1b0') + (this.upsideDown ? '' : this.lf());
        },
        // cut paper: ESC d n
        cut() {
            return '\x1bd3';
        },
        // underline text: ESC - n
        ul() {
            return '\x1b-1';
        },
        // emphasize text: ESC E
        em() {
            return '\x1bE';
        },
        // invert text: ESC 4
        iv() {
            return '\x1b4';
        },
        // scale up text: ESC i n1 n2
        wh(wh) {
            return '\x1bi' + (wh < 3 ? $(wh >> 1 & 1, wh & 1) : $(wh - 2, wh - 2));
        },
        // cancel text decoration: ESC - n ESC F ESC 5 ESC i n1 n2
        normal() {
            return '\x1b-0\x1bF\x1b5\x1bi' + $(0, 0);
        },
        // print text:
        text(text, encoding) {
            return encoding === 'multilingual' ? this.multiconv(text) : this.codepage[encoding] + iconv.encode(text, encoding).toString('binary');
        },
        // codepages: (ESC GS t n) (ESC $ n) (ESC R n)
        codepage: {
            cp437: '\x1b\x1dt\x01', cp852: '\x1b\x1dt\x05', cp858: '\x1b\x1dt\x04', cp860: '\x1b\x1dt\x06',
            cp863: '\x1b\x1dt\x08', cp865: '\x1b\x1dt\x09', cp866: '\x1b\x1dt\x0a', cp1252: '\x1b\x1dt\x20',
            cp932: '\x1b$1\x1bR8', cp936: '', cp949: '\x1bRD', cp950: '',
            shiftjis: '\x1b$1\x1bR8', gb18030: '', ksc5601: '\x1bRD', big5: '', tis620: '\x1b\x1dt\x61'
        },
        // convert to multiple codepage characters: (ESC GS t n)
        multiconv(text) {
            let p = '', r = '';
            for (let i = 0; i < text.length; i++) {
                const c = text[i];
                if (c > '\x7f') {
                    const d = multitable[c];
                    if (d) {
                        const q = d[0];
                        if (p === q) {
                            r += d[1];
                        }
                        else {
                            r += '\x1b\x1dt' + starpage[q] + d[1];
                            p = q;
                        }
                    }
                    else {
                        r += '?';
                    }
                }
                else {
                    r += c;
                }
            }
            return r;
        },
        // feed new line: LF
        lf() {
            return '\x0a';
        },
        // insert commands:
        command(command) {
            return command;
        },
        // image split size
        split: 2400,
        // print image: ESC GS S m xL xH yL yH n [d11 d12 ... d1k]
        async image(image) {
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            const l = w + 7 >> 3;
            const s = [];
            let j = 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                let r = '\x1b\x1dS' + $(1, l & 255, l >> 8 & 255, h & 255, h >> 8 & 255, 0);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
                s.push(r);
            }
            if (this.upsideDown) {
                s.reverse();
            }
            return s.join('');
        },
        // print QR Code: ESC GS y S 0 n ESC GS y S 1 n ESC GS y S 2 n ESC GS y D 1 m nL nH d1 d2 ... dk ESC GS y P
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    const img = qr.createASCII(2, 0).split('\n');
                    const w = img.length * symbol.cell;
                    const h = w;
                    const l = w + 7 >> 3;
                    r += '\x1b\x1dS' + $(1, l & 255, l >> 8 & 255, h & 255, h >> 8 & 255, 0);
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            r += d;
                        }
                    }
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return d.length > 0 ? '\x1b\x1dyS0' + $(2) + '\x1b\x1dyS1' + $(this.qrlevel[symbol.level]) + '\x1b\x1dyS2' + $(symbol.cell) + '\x1b\x1dyD1' + $(0, d.length & 255, d.length >> 8 & 255) + d + '\x1b\x1dyP' : '';
            }
        },
        // QR Code error correction levels:
        qrlevel: {
            l: 0, m: 1, q: 2, h: 3
        },
        // print barcode: ESC b n1 n2 n3 n4 d1 ... dk RS
        barcode(symbol, encoding) {
            let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
            const b = this.bartype[symbol.type] - Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
            switch (b) {
                case this.bartype.upc - 1:
                    d = this.upce(d);
                    break;
                case this.bartype.code128:
                    d = this.code128(d);
                    break;
                default:
                    break;
            }
            const u = symbol.type === 'itf' ? [ 49, 56, 50 ][symbol.width - 2] : symbol.width + (/^(code39|codabar|nw7)$/.test(symbol.type) ? 50 : 47);
            return d.length > 0 ? '\x1bb' + $(b, symbol.hri ? 50 : 49, u, symbol.height) + d + '\x1e' : '';
        },
        // barcode types:
        bartype: {
            upc: 49, ean: 51, jan: 51, code39: 52, itf: 53, codabar: 56, nw7: 56, code93: 55, code128: 54
        },
        // generate UPC-E data (convert UPC-E to UPC-A):
        upce(data) {
            let r = '';
            let s = data.replace(/((?!^0\d{6,7}$).)*/, '');
            if (s.length > 0) {
                r += s.slice(0, 3);
                switch (s[6]) {
                    case '0': case '1': case '2':
                        r += s[6] + '0000' + s[3] + s[4] + s[5];
                        break;
                    case '3':
                        r += s[3] + '00000' + s[4] + s[5];
                        break;
                    case '4':
                        r += s[3] + s[4] + '00000' + s[5];
                        break;
                    default:
                        r += s[3] + s[4] + s[5] + '0000' + s[6];
                        break;
                }
            }
            return r;
        },
        // generate CODE128 data:
        code128(data) {
            return data.replace(/((?!^[\x00-\x7f]+$).)*/, '').replace(/%/g, '%0').replace(/[\x00-\x1f]/g, m => '%' + $(m.charCodeAt(0) + 64)).replace(/\x7f/g, '%5');
        }
    };

    //
    // Star Line Mode
    //
    const _line = {
        // finish printing: ESC GS ETX s n1 n2 EOT
        close() {
            return (this.cutting ? this.cut() : '') + '\x1b\x1d\x03\x01\x00\x00\x04';
        },
        // print image: ESC k n1 n2 d1 ... dk
        async image(image) {
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const h = img.height;
            const d = Array(w).fill(0);
            const l = w + 7 >> 3;
            const s = [];
            let j = 0;
            for (let y = 0; y < h; y += 24) {
                let r = '\x1bk' + $(l & 255, l >> 8 & 255);
                for (let z = 0; z < 24; z++) {
                    if (y + z < h) {
                        let i = 0, e = 0;
                        for (let x = 0; x < w; x += 8) {
                            let b = 0;
                            const q = Math.min(w - x, 8);
                            for (let p = 0; p < q; p++) {
                                const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                                j += 4;
                                if (this.gradient) {
                                    d[i] = e * 3;
                                    e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                    if (i > 0) {
                                        d[i - 1] += e;
                                    }
                                    d[i++] += e * 7;
                                }
                                else {
                                    if (f < this.threshold) {
                                        b |= 128 >> p;
                                    }
                                }
                            }
                            r += $(b);
                        }
                    }
                    else {
                        r += '\x00'.repeat(l);
                    }
                }
                s.push(r + '\x0a');
            }
            if (this.upsideDown) {
                s.reverse();
            }
            return '\x1b0' + s.join('') + (this.spacing ? '\x1bz1' : '\x1b0');
        },
        // print QR Code: ESC GS y S 0 n ESC GS y S 1 n ESC GS y S 2 n ESC GS y D 1 m nL nH d1 d2 ... dk ESC GS y P
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    const img = qr.createASCII(2, 0).split('\n');
                    const w = img.length * symbol.cell;
                    const l = w + 7 >> 3;
                    const s = [];
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            s.push(d);
                        }
                    }
                    while (s.length % 24) {
                        const d = '\x00'.repeat(l);
                        s.push(d);
                    }
                    if (this.upsideDown) {
                        s.reverse();
                    }
                    r += '\x1b0';
                    for (let k = 0; k < s.length; k += 24) {
                        const a = s.slice(k, k + 24);
                        if (this.upsideDown) {
                            a.reverse();
                        }
                        r += '\x1bk' + $(l & 255, l >> 8 & 255) + a.join('') + '\x0a';
                    }
                    r += (this.spacing ? '\x1bz1' : '\x1b0');
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return '\x1b\x1dyS0' + $(2) + '\x1b\x1dyS1' + $(this.qrlevel[symbol.level]) + '\x1b\x1dyS2' + $(symbol.cell) + '\x1b\x1dyD1' + $(0, d.length & 255, d.length >> 8 & 255) + d + '\x1b\x1dyP';
            }
        }
    };

    //
    // Star Mode on dot impact printers
    //
    const _dot = {
        font: 0,
        // start printing: ESC @ ESC RS a n (ESC M) (ESC P) (ESC :) ESC SP n ESC s n1 n2 (ESC z n) (ESC 0) (SI) (DC2)
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.margin = printer.margin;
            return '\x1b@\x1b\x1ea\x00\x1b' + [ 'M', 'P', ':' ][this.font] + '\x1b \x00\x1bs\x00\x00' + (this.spacing ? '\x1bz\x01' : '\x1b0') + (this.upsideDown ? '\x0f' : '\x12');
        },
        // finish printing: ESC GS ETX s n1 n2 EOT
        close() {
            return (this.cutting ? this.cut() : '') + '\x1b\x1d\x03\x01\x00\x00\x04';
        },
        // scale up text: ESC W n ESC h n
        wh(wh) {
            return '\x1bW' + $(wh < 3 ? wh & 1 : 1) + '\x1bh' + $(wh < 3 ? wh >> 1 & 1 : 1);
        },
        // cancel text decoration: ESC - n ESC F ESC 5 ESC W n ESC h n
        normal() {
            return '\x1b-\x00\x1bF\x1b5\x1bW' + $(0) + '\x1bh' + $(0);
        },
        // print image: ESC 0 ESC K n NUL d1 ... dn LF (ESC z n) (ESC 0)
        async image(image) {
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = Math.min(img.width, 255);
            const d = Array(w).fill(0);
            const s = [];
            for (let y = 0; y < img.height; y += 8) {
                const b = Array(w).fill(0);
                const h = Math.min(8, img.height - y);
                for (let p = 0; p < h; p++) {
                    let i = 0, e = 0;
                    let j = (y + p) * img.width * 4;
                    for (let x = 0; x < w; x++) {
                        const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                        j += 4;
                        if (this.gradient) {
                            d[i] = e * 3;
                            e = f < this.threshold ? (b[x] |= 128 >> p, f) : f - 255;
                            if (i > 0) {
                                d[i - 1] += e;
                            }
                            d[i++] += e * 7;
                        }
                        else {
                            if (f < this.threshold) {
                                b[x] |= 128 >> p;
                            }
                        }
                    }
                }
                s.push('\x1bK' + $(w) + '\x00' + b.reduce((a, c) => a + $(c), '') + '\x0a');
            }
            if (this.upsideDown) {
                s.reverse();
            }
            return '\x1b0' + s.join('') + (this.spacing ? '\x1bz\x01' : '\x1b0');
        },
        // print QR Code:
        qrcode(symbol, encoding) {
            return '';
        },
        // print barcode:
        barcode(symbol, encoding) {
            return '';
        }
    };

    //
    // Star Mode on dot impact printers (Font 5x9 2P-1)
    //
    const _font2 = {
        font: 1,
    };

    //
    // Star Mode on dot impact printers (Font 5x9 3P-1)
    //
    const _font3 = {
        font: 2,
    };

    //
    // Command Emulator Star Line Mode
    //
    const _emu = {
        // set line spacing and feed new line: (ESC z n) (ESC 0)
        vrlf(vr) {
            return (vr === this.upsideDown && this.spacing ? '\x1bz1' : '\x1b0') + this.lf();
        }
    };

    //
    // Star SBCS
    //
    const _sbcs = {
        // print horizontal rule: ESC GS t n ...
        hr(width) {
            return '\x1b\x1dt\x01' + '\xc4'.repeat(width);
        },
        // print vertical rules: ESC i n1 n2 ESC GS t n ...
        vr(widths, height) {
            return widths.reduce((a, w) => a + this.relative(w) + '\xb3', '\x1bi' + $(height - 1, 0) + '\x1b\x1dt\x01\xb3');
        },
        // start rules: ESC GS t n ...
        vrstart(widths) {
            return '\x1b\x1dt\x01' + widths.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc2', '\xda').slice(0, -1) + '\xbf';
        },
        // stop rules: ESC GS t n ...
        vrstop(widths) {
            return '\x1b\x1dt\x01' + widths.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc1', '\xc0').slice(0, -1) + '\xd9';
        },
        // print vertical and horizontal rules: ESC GS t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc1', '\xc0').slice(0, -1) + '\xd9' + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc2', '\xda').slice(0, -1) + '\xbf' + ' '.repeat(Math.max(-dr, 0));
            return '\x1b\x1dt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // ruled line composition
        vrtable: {
            ' '    : { ' ' : ' ',    '\xc0' : '\xc0', '\xc1' : '\xc1', '\xc4' : '\xc4', '\xd9' : '\xd9' },
            '\xbf' : { ' ' : '\xbf', '\xc0' : '\xc5', '\xc1' : '\xc5', '\xc4' : '\xc2', '\xd9' : '\xb4' },
            '\xc2' : { ' ' : '\xc2', '\xc0' : '\xc5', '\xc1' : '\xc5', '\xc4' : '\xc2', '\xd9' : '\xc5' },
            '\xc4' : { ' ' : '\xc4', '\xc0' : '\xc1', '\xc1' : '\xc1', '\xc4' : '\xc4', '\xd9' : '\xc1' },
            '\xda' : { ' ' : '\xda', '\xc0' : '\xc3', '\xc1' : '\xc5', '\xc4' : '\xc2', '\xd9' : '\xc5' }
        }
    };

    //
    // Star MBCS Japanese
    //
    const _mbcs = {
        // print horizontal rule: ESC $ n ...
        hr(width) {
            return '\x1b$0' + '\x95'.repeat(width);
        },
        // print vertical rules: ESC i n1 n2 ESC $ n ...
        vr(widths, height) {
            return widths.reduce((a, w) => a + this.relative(w) + '\x96', '\x1bi' + $(height - 1, 0) + '\x1b$0\x96');
        },
        // start rules: ESC $ n ...
        vrstart(widths) {
            return '\x1b$0' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
        },
        // stop rules: ESC $ n ...
        vrstop(widths) {
            return '\x1b$0' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
        },
        // print vertical and horizontal rules: ESC $ n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            return '\x1b$0' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // ruled line composition
        vrtable: {
            ' '    : { ' ' : ' ',    '\x90' : '\x90', '\x95' : '\x95', '\x9a' : '\x9a', '\x9b' : '\x9b', '\x9e' : '\x9e', '\x9f' : '\x9f' },
            '\x91' : { ' ' : '\x91', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x8f', '\x9e' : '\x8f', '\x9f' : '\x8f' },
            '\x95' : { ' ' : '\x95', '\x90' : '\x90', '\x95' : '\x95', '\x9a' : '\x90', '\x9b' : '\x90', '\x9e' : '\x90', '\x9f' : '\x90' },
            '\x98' : { ' ' : '\x98', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x93', '\x9b' : '\x8f', '\x9e' : '\x93', '\x9f' : '\x8f' },
            '\x99' : { ' ' : '\x99', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x92', '\x9e' : '\x8f', '\x9f' : '\x92' },
            '\x9c' : { ' ' : '\x9c', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x93', '\x9b' : '\x8f', '\x9e' : '\x93', '\x9f' : '\x8f' },
            '\x9d' : { ' ' : '\x9d', '\x90' : '\x8f', '\x95' : '\x91', '\x9a' : '\x8f', '\x9b' : '\x92', '\x9e' : '\x8f', '\x9f' : '\x92' }
        }
    };

    //
    // Star MBCS Chinese Korean
    //
    const _mbcs2 = {
        // print horizontal rule: - ...
        hr(width) {
            return '-'.repeat(width);
        },
        // print vertical rules: ESC i n1 n2 | ...
        vr(widths, height) {
            return widths.reduce((a, w) => a + this.relative(w) + '|', '\x1bi' + $(height - 1, 0) + '|');
        },
        // start rules: + - ...
        vrstart(widths) {
            return widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
        },
        // stop rules: + - ...
        vrstop(widths) {
            return widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
        },
        // print vertical and horizontal rules: + - ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(-dr, 0));
            return r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // ruled line composition
        vrtable: {
            ' ' : { ' ' : ' ', '+' : '+', '-' : '-' },
            '+' : { ' ' : '+', '+' : '+', '-' : '+' },
            '-' : { ' ' : '-', '+' : '+', '-' : '-' }
        }
    };

    //
    // Star Graphic Mode
    //
    const _stargraphic = {
        // printer configuration
        upsideDown: false,
        spacing: false,
        cutting: true,
        gradient: true,
        gamma: 1.8,
        threshold: 128,
        alignment: 0,
        left: 0,
        width: 48,
        right: 0,
        margin: 0,
        // start printing: ESC RS a n ESC * r A ESC * r P n NUL (ESC * r E n NUL)
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.margin = (printer.upsideDown ? printer.marginRight : printer.margin) * this.charWidth;
            return '\x1b\x1ea\x00\x1b*rA\x1b*rP0\x00' + (this.cutting ? '' : '\x1b*rE1\x00');
        },
        // finish printing: ESC * r B ESC ACK SOH
        close() {
            return '\x1b*rB\x1b\x06\x01';
        },
        // set print area:
        area(left, width, right) {
            this.left = left;
            this.width = width;
            this.right = right;
            return '';
        },
        // set line alignment:
        align(align) {
            this.alignment = align;
            return '';
        },
        // cut paper: ESC FF NUL
        cut() {
            return '\x1b\x0c\x00';
        },
        // feed new line: ESC * r Y n NUL
        lf() {
            return '\x1b*rY' + this.charWidth * (this.spacing ? 2.5 : 2) + '\x00';
        },
        // insert commands:
        command(command) {
            return command;
        },
        // print image: b n1 n2 data
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const right = arguments[4] || this.right;
            let r = '';
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            const m = this.margin + Math.max((this.upsideDown ? right : left) * this.charWidth + (width * this.charWidth - w) * (this.upsideDown ? 2 - align : align) >> 1, 0);
            const l = m + w + 7 >> 3;
            let j = this.upsideDown ? img.data.length - 4 : 0;
            for (let y = 0; y < img.height; y++) {
                let i = 0, e = 0;
                r += 'b' + $(l & 255, l >> 8 & 255);
                for (let x = 0; x < m + w; x += 8) {
                    let b = 0;
                    const q = Math.min(m + w - x, 8);
                    for (let p = 0; p < q; p++) {
                        if (m <= x + p) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += this.upsideDown ? -4 : 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                    }
                    r += $(b);
                }
            }
            return r;
        }
    };

    //
    // ESC/POS Generic
    //
    const _generic = {
        // start printing: ESC @ GS a n ESC M n ESC SP n FS S n1 n2 (ESC 2) (ESC 3 n) ESC { n FS .
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            return '\x1b@\x1da\x00\x1bM\x00\x1b \x00\x1cS\x00\x00' + (this.spacing ? '\x1b2' : '\x1b3\x00') + '\x1b{' + $(this.upsideDown) + '\x1c.';
        },
        // finish printing: GS r n
        close() {
            return (this.cutting ? this.cut() : '') + '\x1dr\x01';
        },
        // print horizontal rule: FS C n FS . ESC t n ...
        hr(width) {
            return '\x1cC\x00\x1c.\x1bt\x01' + '\x95'.repeat(width);
        },
        // print vertical rules: GS ! n FS C n FS . ESC t n ...
        vr(widths, height) {
            return widths.reduce((a, w) => a + this.relative(w) + '\x96', '\x1d!' + $(height - 1) + '\x1cC\x00\x1c.\x1bt\x01\x96');
        },
        // start rules: FS C n FS . ESC t n ...
        vrstart(widths) {
            return '\x1cC\x00\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
        },
        // stop rules: FS C n FS . ESC t n ...
        vrstop(widths) {
            return '\x1cC\x00\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
        },
        // print vertical and horizontal rules: FS C n FS . ESC t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            return '\x1cC\x00\x1c.\x1bt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
        },
        // underline text: ESC - n FS - n
        ul() {
            return '\x1b-\x02\x1c-\x02';
        },
        // emphasize text: ESC E n
        em() {
            return '\x1bE\x01';
        },
        // invert text: GS B n
        iv() {
            return '\x1dB\x01';
        },
        // scale up text: GS ! n
        wh(wh) {
            return '\x1d!' + (wh < 3 ? $((wh & 1) << 4 | wh >> 1 & 1) : $(wh - 2 << 4 | wh - 2));
        },
        // cancel text decoration: ESC - n FS - n ESC E n GS B n GS ! n
        normal() {
            return '\x1b-\x00\x1c-\x00\x1bE\x00\x1dB\x00\x1d!\x00';
        },
        // image split size
        split: 2048,
        // print image: GS v 0 m xL xH yL yH d1 ... dk
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const right = arguments[4] || this.right;
            let r = this.upsideDown ? this.area(right + this.marginRight - this.margin, width, left) + this.align(2 - align) : '';
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const d = Array(w).fill(0);
            let j = this.upsideDown ? img.data.length - 4 : 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = w + 7 >> 3;
                r += '\x1dv0' + $(0, l & 255, l >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += this.upsideDown ? -4 : 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
            }
            return r;
        },
        // print QR Code: GS ( k pL pH cn fn n1 n2 GS ( k pL pH cn fn n GS ( k pL pH cn fn n GS ( k pL pH cn fn m d1 ... dk GS ( k pL pH cn fn m
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined') {
                let r = this.upsideDown ? this.area(this.right + this.marginRight - this.margin, this.width, this.left) + this.align(2 - this.alignment) : '';
                if (symbol.data.length > 0) {
                    const qr = qrcode(0, symbol.level.toUpperCase());
                    qr.addData(symbol.data);
                    qr.make();
                    let img = qr.createASCII(2, 0);
                    if (this.upsideDown) {
                        img = img.split('').reverse().join('');
                    }
                    img = img.split('\n');
                    const w = img.length * symbol.cell;
                    const h = w;
                    const l = w + 7 >> 3;
                    r += '\x1dv0' + $(0, l & 255, l >> 8 & 255, h & 255, h >> 8 & 255);
                    for (let i = 0; i < img.length; i++) {
                        let d = '';
                        for (let j = 0; j < w; j += 8) {
                            let b = 0;
                            const q = Math.min(w - j, 8);
                            for (let p = 0; p < q; p++) {
                                if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                    b |= 128 >> p;
                                }
                            }
                            d += $(b);
                        }
                        for (let k = 0; k < symbol.cell; k++) {
                            r += d;
                        }
                    }
                }
                return r;
            }
            else {
                const d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary').slice(0, 7089);
                return d.length > 0 ? '\x1d(k' + $(4, 0, 49, 65, 50, 0) + '\x1d(k' + $(3, 0, 49, 67, symbol.cell) + '\x1d(k' + $(3, 0, 49, 69, this.qrlevel[symbol.level]) + '\x1d(k' + $(d.length + 3 & 255, d.length + 3 >> 8 & 255, 49, 80, 48) + d + '\x1d(k' + $(3, 0, 49, 81, 48) : '';
            }
        }
    };

    //
    // ESC/POS Thermal Landscape
    //
    const _escpos90 = {
        position: 0,
        content: '',
        height: 1,
        feed: 24,
        cpl: 48,
        buffer: '',
        // start printing: ESC @ GS a n ESC M n FS ( A pL pH fn m ESC SP n FS S n1 n2 FS . GS P x y ESC L ESC T n
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.position = 0;
            this.content = '';
            this.height = 1;
            this.feed = this.charWidth * (printer.spacing ? 2.5 : 2);
            this.cpl = printer.cpl;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            this.buffer = '';
            const r = printer.resolution;
            return '\x1b@\x1da\x00\x1bM' + (printer.encoding === 'tis620' ? 'a' : '0') + '\x1c(A' + $(2, 0, 48, 0) + '\x1b \x00\x1cS\x00\x00\x1c.\x1dP' + $(r, r) + '\x1bL\x1bT' + $(printer.upsideDown ? 3 : 1);
        },
        // finish printing: ESC W xL xH yL yH dxL dxH dyL dyH FF GS r n
        close() {
            const w = this.position;
            const h = this.cpl * this.charWidth;
            const v = (this.margin + this.cpl + this.marginRight) * this.charWidth;
            const m = (this.upsideDown ? this.margin : this.marginRight) * this.charWidth;
            return '\x1bW' + $(0, 0, 0, 0, w & 255, w >> 8 & 255, v & 255, v >> 8 & 255) + ' \x1bW' + $(0, 0, m & 255, m >> 8 & 255, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255) + this.buffer + '\x0c' + (this.cutting ? this.cut() : '') + '\x1dr1';
        },
        // set print area:
        area(left, width, right) {
            this.left = left;
            this.width = width;
            this.right = right;
            return '';
        },
        // set line alignment:
        align(align) {
            this.alignment = align;
            return '';
        },
        // set absolute print position: ESC $ nL nH
        absolute(position) {
            const p = (this.left + position) * this.charWidth;
            this.content += '\x1b$' + $(p & 255, p >> 8 & 255);
            return '';
        },
        // set relative print position: ESC \ nL nH
        relative(position) {
            const p = position * this.charWidth;
            this.content += '\x1b\\' + $(p & 255, p >> 8 & 255);
            return '';
        },
        // print horizontal rule: FS C n FS . ESC t n ...
        hr(width) {
            this.content += '\x1cC0\x1c.\x1bt\x01' + '\x95'.repeat(width);
            return '';
        },
        // print vertical rules: GS ! n FS C n FS . ESC t n ...
        vr(widths, height) {
            this.content += widths.reduce((a, w) => {
                const p = w * this.charWidth;
                return a + '\x1b\\' + $(p & 255, p >> 8 & 255) + '\x96';
            }, '\x1d!' + $(height - 1) + '\x1cC0\x1c.\x1bt\x01\x96');
            return '';
        },
        // start rules: FS C n FS . ESC t n ...
        vrstart(widths) {
            this.content += '\x1cC0\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
            return '';
        },
        // stop rules: FS C n FS . ESC t n ...
        vrstop(widths) {
            this.content += '\x1cC0\x1c.\x1bt\x01' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
            return '';
        },
        // print vertical and horizontal rules: FS C n FS . ESC t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            this.content += '\x1cC0\x1c.\x1bt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
            return '';
        },
        // set line spacing and feed new line:
        vrlf(vr) {
            this.feed = this.charWidth * (!vr && this.spacing ? 2.5 : 2);
            return this.lf();
        },
        // underline text: ESC - n FS - n
        ul() {
            this.content += '\x1b-2\x1c-2';
            return '';
        },
        // emphasize text: ESC E n
        em() {
            this.content += '\x1bE1';
            return '';
        },
        // invert text: GS B n
        iv() {
            this.content += '\x1dB1';
            return '';
        },
        // scale up text: GS ! n
        wh(wh) {
            this.height = Math.max(this.height, wh < 3 ? wh : wh - 1);
            this.content += '\x1d!' + (wh < 3 ? $((wh & 1) << 4 | wh >> 1 & 1) : $(wh - 2 << 4 | wh - 2));
            return '';
        },
        // cancel text decoration: ESC - n FS - n ESC E n GS B n GS ! n
        normal() {
            this.content += '\x1b-0\x1c-0\x1bE0\x1dB0\x1d!\x00';
            return '';
        },
        // print text:
        text(text, encoding) {
            switch (encoding) {
                case 'multilingual':
                    this.content += this.multiconv(text);
                    break;
                case 'tis620':
                    this.content += this.codepage[encoding] + this.arrayFrom(text, encoding).reduce((a, c) => a + '\x00' + iconv.encode(c, encoding).toString('binary'), '');
                    break;
                default:
                    this.content += this.codepage[encoding] + iconv.encode(text, encoding).toString('binary');
                    break;
            }
            return '';
        },
        // feed new line: GS $ nL nH ESC $ nL nH
        lf() {
            const h = this.height * this.charWidth * 2;
            const x = this.left * this.charWidth;
            const y = this.position + h * 21 / 24 - 1;
            this.buffer += '\x1d$' + $(y & 255, y >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255) + this.content;
            this.position += Math.max(h, this.feed);
            this.height = 1;
            this.content = '';
            return '';
        },
        // print image: GS $ nL nH ESC $ nL nH GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const x = left * this.charWidth + align * (width * this.charWidth - w) / 2;
            const y = this.position;
            let r = '';
            const d = Array(w).fill(0);
            let j = 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d$' + $(y + h - 1 & 255, y + h - 1 >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255) + '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
            }
            this.buffer += r;
            this.position += img.height;
            return '';
        },
        // print QR Code: GS $ nL nH ESC $ nL nH GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined' && symbol.data.length > 0) {
                const qr = qrcode(0, symbol.level.toUpperCase());
                qr.addData(symbol.data);
                qr.make();
                const img = qr.createASCII(2, 0).split('\n');
                const w = img.length * symbol.cell;
                const h = w;
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position;
                let r = '\x1d$' + $(y + h - 1 & 255, y + h - 1 >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let i = 0; i < img.length; i++) {
                    let d = '';
                    for (let j = 0; j < w; j += 8) {
                        let b = 0;
                        const q = Math.min(w - j, 8);
                        for (let p = 0; p < q; p++) {
                            if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                b |= 128 >> p;
                            }
                        }
                        d += $(b);
                    }
                    for (let k = 0; k < symbol.cell; k++) {
                        r += d;
                    }
                }
                this.buffer += r;
                this.position += h;
            }
            return '';
        },
        // print barcode: GS $ nL nH ESC $ nL nH GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            const bar = Receipt.barcode.generate(symbol);
            if ('length' in bar) {
                const w = bar.length;
                const l = symbol.height;
                const h = l + (symbol.hri ? this.charWidth * 2 + 2 : 0);
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position;
                let r = '\x1d$' + $(y + l - 1 & 255, y + l - 1 >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255);
                let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
                const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
                switch (b) {
                    case this.bartype.ean:
                        d = d.slice(0, 12);
                        break;
                    case this.bartype.upc:
                        d = d.slice(0, 11);
                        break;
                    case this.bartype.ean + 1:
                        d = d.slice(0, 7);
                        break;
                    case this.bartype.upc + 1:
                        d = this.upce(d);
                        break;
                    case this.bartype.code128:
                        d = this.code128(d);
                        break;
                    default:
                        break;
                }
                d = d.slice(0, 255);
                r += '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d;
                this.buffer += r;
                this.position += h;
            }
            return '';
        }
    };

    //
    // SII Landscape
    //
    const _sii90 = {
        // start printing: ESC @ GS a n ESC M n ESC SP n FS S n1 n2 FS . GS P x y ESC L ESC T n
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.right = 0;
            this.position = 0;
            this.content = '';
            this.height = 1;
            this.feed = this.charWidth * (printer.spacing ? 2.5 : 2);
            this.cpl = printer.cpl;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            this.buffer = '';
            const r = printer.resolution;
            return '\x1b@\x1da\x00\x1bM0\x1b \x00\x1cS\x00\x00\x1c.\x1dP' + $(r, r) + '\x1bL\x1bT' + $(printer.upsideDown ? 3 : 1);
        },
        // finish printing: ESC W xL xH yL yH dxL dxH dyL dyH ESC $ nL nH FF DC2 q n
        close() {
            const w = this.position;
            const h = this.cpl * this.charWidth;
            const v = (this.margin + this.cpl + this.marginRight) * this.charWidth;
            const m = (this.upsideDown ? this.margin : this.marginRight) * this.charWidth;
            return '\x1bW' + $(0, 0, 0, 0, w & 255, w >> 8 & 255, v & 255, v >> 8 & 255) + ' \x1bW' + $(0, 0, m & 255, m >> 8 & 255, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255) + this.buffer + '\x0c' + (this.cutting ? this.cut() : '') + '\x12q\x00';
        },
        // feed new line: GS $ nL nH ESC $ nL nH
        lf() {
            const h = this.height * this.charWidth * 2;
            const x = this.left * this.charWidth;
            const y = this.position + h;
            this.buffer += '\x1d$' + $(y & 255, y >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255) + this.content;
            this.position += Math.max(h, this.feed);
            this.height = 1;
            this.content = '';
            return '';
        },
        // print image: GS $ nL nH ESC $ nL nH GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const x = left * this.charWidth + align * (width * this.charWidth - w) / 2;
            const y = this.position;
            let r = '';
            const d = Array(w).fill(0);
            let j = 0;
            for (let z = 0; z < img.height; z += this.split) {
                const h = Math.min(this.split, img.height - z);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d$' + $(y + h & 255, y + h >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255) + '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let y = 0; y < h; y++) {
                    let i = 0, e = 0;
                    for (let x = 0; x < w; x += 8) {
                        let b = 0;
                        const q = Math.min(w - x, 8);
                        for (let p = 0; p < q; p++) {
                            const f = Math.floor((d[i] + e * 5) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                            j += 4;
                            if (this.gradient) {
                                d[i] = e * 3;
                                e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                if (i > 0) {
                                    d[i - 1] += e;
                                }
                                d[i++] += e * 7;
                            }
                            else {
                                if (f < this.threshold) {
                                    b |= 128 >> p;
                                }
                            }
                        }
                        r += $(b);
                    }
                }
            }
            this.buffer += r;
            this.position += img.height;
            return '';
        },
        // print QR Code: GS $ nL nH ESC $ nL nH GS 8 L p1 p2 p3 p4 m fn a bx by c xL xH yL yH d1 ... dk
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined' && symbol.data.length > 0) {
                const qr = qrcode(0, symbol.level.toUpperCase());
                qr.addData(symbol.data);
                qr.make();
                const img = qr.createASCII(2, 0).split('\n');
                const w = img.length * symbol.cell;
                const h = w;
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position;
                let r = '\x1d$' + $(y + h & 255, y + h >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255);
                const l = (w + 7 >> 3) * h + 10;
                r += '\x1d8L' + $(l & 255, l >> 8 & 255, l >> 16 & 255, l >> 24 & 255, 48, 112, 48, 1, 1, 49, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255);
                for (let i = 0; i < img.length; i++) {
                    let d = '';
                    for (let j = 0; j < w; j += 8) {
                        let b = 0;
                        const q = Math.min(w - j, 8);
                        for (let p = 0; p < q; p++) {
                            if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                b |= 128 >> p;
                            }
                        }
                        d += $(b);
                    }
                    for (let k = 0; k < symbol.cell; k++) {
                        r += d;
                    }
                }
                this.buffer += r;
                this.position += h;
            }
            return '';
        },
        // print barcode: GS $ nL nH ESC $ nL nH GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            const bar = Receipt.barcode.generate(symbol);
            if ('length' in bar) {
                const w = bar.length + symbol.width * (/^(upc|ean|jan)$/.test(symbol.type) ? (data.length < 9 ? 14 : 18) : 20);
                const l = symbol.height;
                const h = l + (symbol.hri ? this.charWidth * 2 + 4 : 0);
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position;
                let r = '\x1d$' + $(y + l & 255, y + l >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255);
                let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
                const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
                switch (b) {
                    case this.bartype.upc + 1:
                        d = this.upce(d);
                        break;
                    case this.bartype.codabar:
                        d = this.codabar(d);
                        break;
                    case this.bartype.code93:
                        d = this.code93(d);
                        break;
                    case this.bartype.code128:
                        d = this.code128(d);
                        break;
                    default:
                        break;
                }
                d = d.slice(0, 255);
                r += '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d;
                this.buffer += r;
                this.position += h;
            }
            return '';
        }
    };

    //
    // Citizen Landscape
    //
    const _citizen90 = {
        // print barcode: GS $ nL nH ESC $ nL nH GS w n GS h n GS H n GS k m n d1 ... dn
        barcode(symbol, encoding) {
            const bar = Receipt.barcode.generate(symbol);
            if ('length' in bar) {
                const w = bar.length;
                const l = symbol.height;
                const h = l + (symbol.hri ? this.charWidth * 2 + 2 : 0);
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position;
                let r = '\x1d$' + $(y + l - 1 & 255, y + l - 1 >> 8 & 255) + '\x1b$' + $(x & 255, x >> 8 & 255);
                let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
                const b = this.bartype[symbol.type] + Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
                switch (b) {
                    case this.bartype.ean:
                        d = d.slice(0, 12);
                        break;
                    case this.bartype.upc:
                        d = d.slice(0, 11);
                        break;
                    case this.bartype.ean + 1:
                        d = d.slice(0, 7);
                        break;
                    case this.bartype.upc + 1:
                        d = this.upce(d);
                        break;
                    case this.bartype.codabar:
                        d = this.codabar(d);
                        break;
                    case this.bartype.code128:
                        d = this.code128(d);
                        break;
                    default:
                        break;
                }
                d = d.slice(0, 255);
                r += '\x1dw' + $(symbol.width) + '\x1dh' + $(symbol.height) + '\x1dH' + $(symbol.hri ? 2 : 0) + '\x1dk' + $(b, d.length) + d;
                this.buffer += r;
                this.position += h;
            }
            return '';
        }
    };

    //
    // Star Landscape
    //
    const _star90 = {
        alignment: 0,
        width: 48,
        left: 0,
        position: 0,
        content: '',
        height: 1,
        feed: 24,
        cpl: 48,
        marginRight: 0,
        buffer: '',
        // start printing: ESC @ ESC RS a n (ESC RS R n) ESC RS F n ESC SP n ESC s n1 n2 ESC GS P 0 ESC GS P 2 n
        open(printer) {
            this.upsideDown = printer.upsideDown;
            this.spacing = printer.spacing;
            this.cutting = printer.cutting;
            this.gradient = printer.gradient;
            this.gamma = printer.gamma;
            this.threshold = printer.threshold;
            this.alignment = 0;
            this.left = 0;
            this.width = printer.cpl;
            this.position = 0;
            this.content = '';
            this.height = 1;
            this.feed = this.charWidth * (printer.spacing ? 2.5 : 2);
            this.cpl = printer.cpl;
            this.margin = printer.margin;
            this.marginRight = printer.marginRight;
            this.buffer = '';
            return '\x1b@\x1b\x1ea\x00' + (printer.encoding === 'tis620' ? '\x1b\x1eR\x01': '') + '\x1b\x1eF\x00\x1b 0\x1bs00\x1b\x1dP0\x1b\x1dP2' + $(printer.upsideDown ? 3 : 1);
        },
        // finish printing: ESC GS P 3 xL xH yL yH dxL dxH dyL dyH ESC GS P 7 ESC GS ETX s n1 n2
        close() {
            const w = this.position;
            const h = this.cpl * this.charWidth;
            const v = (this.margin + this.cpl + this.marginRight) * this.charWidth;
            const m = (this.upsideDown ? this.margin : this.marginRight) * this.charWidth;
            return '\x1b\x1dP3' + $(0, 0, 0, 0, w & 255, w >> 8 & 255, v & 255, v >> 8 & 255) + ' \x1b\x1dP3' + $(0, 0, m & 255, m >> 8 & 255, w & 255, w >> 8 & 255, h & 255, h >> 8 & 255) + this.buffer + '\x1b\x1dP7' + (this.cutting ? this.cut() : '') + '\x1b\x1d\x03\x01\x00\x00';
        },
        // set print area:
        area(left, width, right) {
            this.left = left;
            this.width = width;
            return '';
        },
        // set line alignment:
        align(align) {
            this.alignment = align;
            return '';
        },
        // set absolute print position: ESC GS A n1 n2
        absolute(position) {
            const p = (this.left + position) * this.charWidth;
            this.content += '\x1b\x1dA' + $(p & 255, p >> 8 & 255);
            return '';
        },
        // set relative print position: ESC GS R n1 n2
        relative(position) {
            const p = position * this.charWidth;
            this.content += '\x1b\x1dR' + $(p & 255, p >> 8 & 255);
            return '';
        },
        // set line spacing and feed new line:
        vrlf(vr) {
            this.feed = this.charWidth * (!vr && this.spacing ? 2.5 : 2);
            return this.lf();
        },
        // underline text: ESC - n
        ul() {
            this.content += '\x1b-1';
            return '';
        },
        // emphasize text: ESC E
        em() {
            this.content += '\x1bE';
            return '';
        },
        // invert text: ESC 4
        iv() {
            this.content += '\x1b4';
            return '';
        },
        // scale up text: ESC i n1 n2
        wh(wh) {
            this.height = Math.max(this.height, wh < 3 ? wh : wh - 1);
            this.content += '\x1bi' + (wh < 3 ? $(wh >> 1 & 1, wh & 1) : $(wh - 2, wh - 2));
            return '';
        },
        // cancel text decoration: ESC - n ESC F ESC 5 ESC i n1 n2
        normal() {
            this.content += '\x1b-0\x1bF\x1b5\x1bi' + $(0, 0);
            return '';
        },
        // print text:
        text(text, encoding) {
            this.content += encoding === 'multilingual' ? this.multiconv(text) : this.codepage[encoding] + iconv.encode(text, encoding).toString('binary');
            return '';
        },
        // feed new line: ESC GS P 4 nL nH ESC GS A n1 n2
        lf() {
            const h = this.height * this.charWidth * 2;
            const x = this.left * this.charWidth;
            const y = this.position + h * 20 / 24;
            this.buffer += '\x1b\x1dP4' + $(y & 255, y >> 8 & 255) + '\x1b\x1dA' + $(x & 255, x >> 8 & 255) + this.content;
            this.position += Math.max(h, this.feed);
            this.height = 1;
            this.content = '';
            return '';
        },
        // print image: ESC GS P 4 nL nH ESC GS A n1 n2 ESC k n1 n2 d1 ... dk
        async image(image) {
            const align = arguments[1] || this.alignment;
            const left = arguments[2] || this.left;
            const width = arguments[3] || this.width;
            const img = await PNG.read(Buffer.from(image, 'base64'));
            const w = img.width;
            const h = img.height;
            const x = left * this.charWidth + align * (width * this.charWidth - w) / 2;
            const y = this.position + this.charWidth * 40 / 24;
            const d = Array(w).fill(0);
            const l = w + 7 >> 3;
            let r = '\x1b0' + '\x1b\x1dP4' + $(y & 255, y >> 8 & 255);
            let j = 0;
            for (let y = 0; y < h; y += 24) {
                r += '\x1b\x1dA' + $(x & 255, x >> 8 & 255) + '\x1bk' + $(l & 255, l >> 8 & 255);
                for (let z = 0; z < 24; z++) {
                    if (y + z < h) {
                        let i = 0, e = 0;
                        for (let x = 0; x < w; x += 8) {
                            let b = 0;
                            const q = Math.min(w - x, 8);
                            for (let p = 0; p < q; p++) {
                                const f = Math.floor((d[i] + e * 7) / 16 + Math.pow(((img.data[j] * .299 + img.data[j + 1] * .587 + img.data[j + 2] * .114 - 255) * img.data[j + 3] + 65525) / 65525, 1 / this.gamma) * 255);
                                j += 4;
                                if (this.gradient) {
                                    d[i] = e * 3;
                                    e = f < this.threshold ? (b |= 128 >> p, f) : f - 255;
                                    if (i > 0) {
                                        d[i - 1] += e;
                                    }
                                    d[i++] += e * 5;
                                }
                                else {
                                    if (f < this.threshold) {
                                        b |= 128 >> p;
                                    }
                                }
                            }
                            r += $(b);
                        }
                    }
                    else {
                        r += '\x00'.repeat(l);
                    }
                }
                r += '\x0a';
            }
            r += (this.spacing ? '\x1bz1' : '\x1b0');
            this.buffer += r;
            this.position += h;
            return '';
        },
        // print QR Code: ESC GS P 4 nL nH ESC GS A n1 n2 ESC k n1 n2 d1 ... dk
        qrcode(symbol, encoding) {
            if (typeof qrcode !== 'undefined' && symbol.data.length > 0) {
                const qr = qrcode(0, symbol.level.toUpperCase());
                qr.addData(symbol.data);
                qr.make();
                const img = qr.createASCII(2, 0).split('\n');
                const w = img.length * symbol.cell;
                const h = w;
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position + this.charWidth * 40 / 24;
                const l = w + 7 >> 3;
                let r = '\x1b0' + '\x1b\x1dP4' + $(y & 255, y >> 8 & 255);
                const s = [];
                for (let i = 0; i < img.length; i++) {
                    let d = '';
                    for (let j = 0; j < w; j += 8) {
                        let b = 0;
                        const q = Math.min(w - j, 8);
                        for (let p = 0; p < q; p++) {
                            if (img[i][Math.floor((j + p) / symbol.cell) * 2] === ' ') {
                                b |= 128 >> p;
                            }
                        }
                        d += $(b);
                    }
                    for (let k = 0; k < symbol.cell; k++) {
                        s.push(d);
                    }
                }
                while (s.length % 24) {
                    const d = '\x00'.repeat(l);
                    s.push(d);
                }
                for (let k = 0; k < s.length; k += 24) {
                    r += '\x1b\x1dA' + $(x & 255, x >> 8 & 255) + '\x1bk' + $(l & 255, l >> 8 & 255) + s.slice(k, k + 24).join('') + '\x0a';
                }
                r += (this.spacing ? '\x1bz1' : '\x1b0');
                this.buffer += r;
                this.position += h;
            }
            return '';
        },
        // print barcode: ESC GS P 4 nL nH ESC GS A n1 n2 ESC b n1 n2 n3 n4 d1 ... dk RS
        barcode(symbol, encoding) {
            const bar = Receipt.barcode.generate(symbol);
            if ('length' in bar) {
                let w = bar.length;
                switch (symbol.type) {
                    case 'code39':
                        w += symbol.width;
                        break;
                    case 'itf':
                        w += bar.widths.reduce((a, c) => (c === 8 ? a + 1 : a), 0);
                        break;
                    case 'code128':
                        w += symbol.width * 11;
                        break;
                    default:
                        break;
                }
                const x = this.left * this.charWidth + this.alignment * (this.width * this.charWidth - w) / 2;
                const y = this.position + symbol.height;
                const h = y + (symbol.hri ? this.charWidth * 2 + 2 : 0);
                let r = '\x1b\x1dP4' + $(y & 255, y >> 8 & 255) + '\x1b\x1dA' + $(x & 255, x >> 8 & 255);
                let d = iconv.encode(symbol.data, encoding === 'multilingual' ? 'ascii' : encoding).toString('binary');
                const b = this.bartype[symbol.type] - Number(/upc|[ej]an/.test(symbol.type) && symbol.data.length < 9);
                switch (b) {
                    case this.bartype.upc - 1:
                        d = this.upce(d);
                        break;
                    case this.bartype.code128:
                        d = this.code128(d);
                        break;
                    default:
                        break;
                }
                const u = symbol.type === 'itf' ? [ 49, 56, 50 ][symbol.width - 2] : symbol.width + (/^(code39|codabar|nw7)$/.test(symbol.type) ? 50 : 47);
                r += '\x1bb' + $(b, symbol.hri ? 50 : 49, u, symbol.height) + d + '\x1e';
                this.buffer += r;
                this.position += h;
            }
            return '';
        }
    };

    //
    // Star SBCS Landscape
    //
    const _sbcs90 = {
        // print horizontal rule: ESC GS t n ...
        hr(width) {
            this.content += '\x1b\x1dt\x01' + '\xc4'.repeat(width);
            return '';
        },
        // print vertical rules: ESC i n1 n2 ESC GS t n ...
        vr(widths, height) {
            this.content += widths.reduce((a, w) => {
                const p = w * this.charWidth;
                return a + '\x1b\x1dR' + $(p & 255, p >> 8 & 255) + '\xb3';
            }, '\x1bi' + $(height - 1, 0) + '\x1b\x1dt\x01\xb3');
            return '';
        },
        // start rules: ESC GS t n ...
        vrstart(widths) {
            this.content += '\x1b\x1dt\x01' + widths.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc2', '\xda').slice(0, -1) + '\xbf';
            return '';
        },
        // stop rules: ESC GS t n ...
        vrstop(widths) {
            this.content += '\x1b\x1dt\x01' + widths.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc1', '\xc0').slice(0, -1) + '\xd9';
            return '';
        },
        // print vertical and horizontal rules: ESC GS t n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc1', '\xc0').slice(0, -1) + '\xd9' + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\xc4'.repeat(w) + '\xc2', '\xda').slice(0, -1) + '\xbf' + ' '.repeat(Math.max(-dr, 0));
            this.content += '\x1b\x1dt\x01' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
            return '';
        }
    };

    //
    // Star MBCS Japanese Landscape
    //
    const _mbcs90 = {
        // print horizontal rule: ESC $ n ...
        hr(width) {
            this.content += '\x1b$0' + '\x95'.repeat(width);
            return '';
        },
        // print vertical rules: ESC i n1 n2 ESC $ n ...
        vr(widths, height) {
            this.content += widths.reduce((a, w) => {
                const p = w * this.charWidth;
                return a + '\x1b\x1dR' + $(p & 255, p >> 8 & 255) + '\x96';
            }, '\x1bi' + $(height - 1, 0) + '\x1b$0\x96');
            return '';
        },
        // start rules: ESC $ n ...
        vrstart(widths) {
            this.content += '\x1b$0' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', '\x9c').slice(0, -1) + '\x9d';
            return '';
        },
        // stop rules: ESC $ n ...
        vrstop(widths) {
            this.content += '\x1b$0' + widths.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', '\x9e').slice(0, -1) + '\x9f';
            return '';
        },
        // print vertical and horizontal rules: ESC $ n ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '\x95'.repeat(w) + '\x90', dl > 0 ? '\x9e' : '\x9a').slice(0, -1) + (dr < 0 ? '\x9f' : '\x9b') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '\x95'.repeat(w) + '\x91', dl < 0 ? '\x9c' : '\x98').slice(0, -1) + (dr > 0 ? '\x9d' : '\x99') + ' '.repeat(Math.max(-dr, 0));
            this.content += '\x1b$0' + r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
            return '';
        }
    };

    //
    // Star MBCS Chinese Korean Landscape
    //
    const _mbcs290 = {
        // print horizontal rule: - ...
        hr(width) {
            this.content += '-'.repeat(width);
            return '';
        },
        // print vertical rules: ESC i n1 n2 | ...
        vr(widths, height) {
            this.content += widths.reduce((a, w) => {
                const p = w * this.charWidth;
                return a + '\x1b\x1dR' + $(p & 255, p >> 8 & 255) + '|';
            }, '\x1bi' + $(height - 1, 0) + '|');
            return '';
        },
        // start rules: + - ...
        vrstart(widths) {
            this.content += widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
            return '';
        },
        // stop rules: + - ...
        vrstop(widths) {
            this.content += widths.reduce((a, w) => a + '-'.repeat(w) + '+', '+');
            return '';
        },
        // print vertical and horizontal rules: + - ...
        vrhr(widths1, widths2, dl, dr) {
            const r1 = ' '.repeat(Math.max(-dl, 0)) + widths1.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(dr, 0));
            const r2 = ' '.repeat(Math.max(dl, 0)) + widths2.reduce((a, w) => a + '-'.repeat(w) + '+', '+') + ' '.repeat(Math.max(-dr, 0));
            this.content += r2.split('').reduce((a, c, i) => a + this.vrtable[c][r1[i]], '');
            return '';
        }
    };

    return {
        /**
         * Create command object.
         * @param {string} command name of command set
         * @returns {object} command object
         */
        create(command) {
            // create command object
            const _base = Receipt.commands.base;
            switch (command) {
                case 'escpos':
                    return { ..._base, ..._escpos, ..._thermal };
                case 'epson':
                    return { ..._base, ..._escpos, ..._thermal };
                case 'sii':
                    return { ..._base, ..._escpos, ..._thermal, ..._sii };
                case 'citizen':
                    return { ..._base, ..._escpos, ..._thermal, ..._citizen };
                case 'fit':
                    return { ..._base, ..._escpos, ..._thermal, ..._fit };
                case 'impact':
                    return { ..._base, ..._escpos, ..._impact };
                case 'impactb':
                    return { ..._base, ..._escpos, ..._impact, ..._fontb };
                case 'generic':
                    return { ..._base, ..._escpos, ..._thermal, ..._generic };
                case 'starsbcs':
                    return { ..._base, ..._star, ..._sbcs };
                case 'starmbcs':
                    return { ..._base, ..._star, ..._mbcs };
                case 'starmbcs2':
                    return { ..._base, ..._star, ..._mbcs2 };
                case 'starlinesbcs':
                    return { ..._base, ..._star, ..._line, ..._sbcs };
                case 'starlinembcs':
                    return { ..._base, ..._star, ..._line, ..._mbcs };
                case 'starlinembcs2':
                    return { ..._base, ..._star, ..._line, ..._mbcs2 };
                case 'emustarlinesbcs':
                    return { ..._base, ..._star, ..._line, ..._emu, ..._sbcs };
                case 'emustarlinembcs':
                    return { ..._base, ..._star, ..._line, ..._emu, ..._mbcs };
                case 'emustarlinembcs2':
                    return { ..._base, ..._star, ..._line, ..._emu, ..._mbcs2 };
                case 'stargraphic':
                    return { ..._base, ..._stargraphic };
                case 'starimpact':
                    return { ..._base, ..._star, ..._dot, ..._sbcs };
                case 'starimpact2':
                    return { ..._base, ..._star, ..._dot, ..._font2, ..._sbcs };
                case 'starimpact3':
                    return { ..._base, ..._star, ..._dot, ..._font3, ..._sbcs };
                case 'escpos90':
                    return { ..._base, ..._escpos, ..._thermal, ..._escpos90 };
                case 'epson90':
                    return { ..._base, ..._escpos, ..._thermal, ..._escpos90 };
                case 'sii90':
                    return { ..._base, ..._escpos, ..._thermal, ..._sii, ..._escpos90, ..._sii90 };
                case 'citizen90':
                    return { ..._base, ..._escpos, ..._thermal, ..._citizen, ..._escpos90, ..._citizen90 };
                case 'starsbcs90':
                    return { ..._base, ..._star, ..._sbcs, ..._star90, ..._sbcs90 };
                case 'starmbcs90':
                    return { ..._base, ..._star, ..._mbcs, ..._star90, ..._mbcs90 };
                case 'starmbcs290':
                    return { ..._base, ..._star, ..._mbcs2, ..._star90, ..._mbcs290 };
                default:
                    return { ..._base };
            }
        }
    };
})();
  </script>
  <script type="text/javascript">
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript
    //
    // Copyright (c) 2009 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    
    var qrcode = function() {
    
      //---------------------------------------------------------------------
      // qrcode
      //---------------------------------------------------------------------
    
      /**
       * qrcode
       * @param typeNumber 1 to 40
       * @param errorCorrectionLevel 'L','M','Q','H'
       */
      var qrcode = function(typeNumber, errorCorrectionLevel) {
    
        var PAD0 = 0xEC;
        var PAD1 = 0x11;
    
        var _typeNumber = typeNumber;
        var _errorCorrectionLevel = QRErrorCorrectionLevel[errorCorrectionLevel];
        var _modules = null;
        var _moduleCount = 0;
        var _dataCache = null;
        var _dataList = [];
    
        var _this = {};
    
        var makeImpl = function(test, maskPattern) {
    
          _moduleCount = _typeNumber * 4 + 17;
          _modules = function(moduleCount) {
            var modules = new Array(moduleCount);
            for (var row = 0; row < moduleCount; row += 1) {
              modules[row] = new Array(moduleCount);
              for (var col = 0; col < moduleCount; col += 1) {
                modules[row][col] = null;
              }
            }
            return modules;
          }(_moduleCount);
    
          setupPositionProbePattern(0, 0);
          setupPositionProbePattern(_moduleCount - 7, 0);
          setupPositionProbePattern(0, _moduleCount - 7);
          setupPositionAdjustPattern();
          setupTimingPattern();
          setupTypeInfo(test, maskPattern);
    
          if (_typeNumber >= 7) {
            setupTypeNumber(test);
          }
    
          if (_dataCache == null) {
            _dataCache = createData(_typeNumber, _errorCorrectionLevel, _dataList);
          }
    
          mapData(_dataCache, maskPattern);
        };
    
        var setupPositionProbePattern = function(row, col) {
    
          for (var r = -1; r <= 7; r += 1) {
    
            if (row + r <= -1 || _moduleCount <= row + r) continue;
    
            for (var c = -1; c <= 7; c += 1) {
    
              if (col + c <= -1 || _moduleCount <= col + c) continue;
    
              if ( (0 <= r && r <= 6 && (c == 0 || c == 6) )
                  || (0 <= c && c <= 6 && (r == 0 || r == 6) )
                  || (2 <= r && r <= 4 && 2 <= c && c <= 4) ) {
                _modules[row + r][col + c] = true;
              } else {
                _modules[row + r][col + c] = false;
              }
            }
          }
        };
    
        var getBestMaskPattern = function() {
    
          var minLostPoint = 0;
          var pattern = 0;
    
          for (var i = 0; i < 8; i += 1) {
    
            makeImpl(true, i);
    
            var lostPoint = QRUtil.getLostPoint(_this);
    
            if (i == 0 || minLostPoint > lostPoint) {
              minLostPoint = lostPoint;
              pattern = i;
            }
          }
    
          return pattern;
        };
    
        var setupTimingPattern = function() {
    
          for (var r = 8; r < _moduleCount - 8; r += 1) {
            if (_modules[r][6] != null) {
              continue;
            }
            _modules[r][6] = (r % 2 == 0);
          }
    
          for (var c = 8; c < _moduleCount - 8; c += 1) {
            if (_modules[6][c] != null) {
              continue;
            }
            _modules[6][c] = (c % 2 == 0);
          }
        };
    
        var setupPositionAdjustPattern = function() {
    
          var pos = QRUtil.getPatternPosition(_typeNumber);
    
          for (var i = 0; i < pos.length; i += 1) {
    
            for (var j = 0; j < pos.length; j += 1) {
    
              var row = pos[i];
              var col = pos[j];
    
              if (_modules[row][col] != null) {
                continue;
              }
    
              for (var r = -2; r <= 2; r += 1) {
    
                for (var c = -2; c <= 2; c += 1) {
    
                  if (r == -2 || r == 2 || c == -2 || c == 2
                      || (r == 0 && c == 0) ) {
                    _modules[row + r][col + c] = true;
                  } else {
                    _modules[row + r][col + c] = false;
                  }
                }
              }
            }
          }
        };
    
        var setupTypeNumber = function(test) {
    
          var bits = QRUtil.getBCHTypeNumber(_typeNumber);
    
          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[Math.floor(i / 3)][i % 3 + _moduleCount - 8 - 3] = mod;
          }
    
          for (var i = 0; i < 18; i += 1) {
            var mod = (!test && ( (bits >> i) & 1) == 1);
            _modules[i % 3 + _moduleCount - 8 - 3][Math.floor(i / 3)] = mod;
          }
        };
    
        var setupTypeInfo = function(test, maskPattern) {
    
          var data = (_errorCorrectionLevel << 3) | maskPattern;
          var bits = QRUtil.getBCHTypeInfo(data);
    
          // vertical
          for (var i = 0; i < 15; i += 1) {
    
            var mod = (!test && ( (bits >> i) & 1) == 1);
    
            if (i < 6) {
              _modules[i][8] = mod;
            } else if (i < 8) {
              _modules[i + 1][8] = mod;
            } else {
              _modules[_moduleCount - 15 + i][8] = mod;
            }
          }
    
          // horizontal
          for (var i = 0; i < 15; i += 1) {
    
            var mod = (!test && ( (bits >> i) & 1) == 1);
    
            if (i < 8) {
              _modules[8][_moduleCount - i - 1] = mod;
            } else if (i < 9) {
              _modules[8][15 - i - 1 + 1] = mod;
            } else {
              _modules[8][15 - i - 1] = mod;
            }
          }
    
          // fixed module
          _modules[_moduleCount - 8][8] = (!test);
        };
    
        var mapData = function(data, maskPattern) {
    
          var inc = -1;
          var row = _moduleCount - 1;
          var bitIndex = 7;
          var byteIndex = 0;
          var maskFunc = QRUtil.getMaskFunction(maskPattern);
    
          for (var col = _moduleCount - 1; col > 0; col -= 2) {
    
            if (col == 6) col -= 1;
    
            while (true) {
    
              for (var c = 0; c < 2; c += 1) {
    
                if (_modules[row][col - c] == null) {
    
                  var dark = false;
    
                  if (byteIndex < data.length) {
                    dark = ( ( (data[byteIndex] >>> bitIndex) & 1) == 1);
                  }
    
                  var mask = maskFunc(row, col - c);
    
                  if (mask) {
                    dark = !dark;
                  }
    
                  _modules[row][col - c] = dark;
                  bitIndex -= 1;
    
                  if (bitIndex == -1) {
                    byteIndex += 1;
                    bitIndex = 7;
                  }
                }
              }
    
              row += inc;
    
              if (row < 0 || _moduleCount <= row) {
                row -= inc;
                inc = -inc;
                break;
              }
            }
          }
        };
    
        var createBytes = function(buffer, rsBlocks) {
    
          var offset = 0;
    
          var maxDcCount = 0;
          var maxEcCount = 0;
    
          var dcdata = new Array(rsBlocks.length);
          var ecdata = new Array(rsBlocks.length);
    
          for (var r = 0; r < rsBlocks.length; r += 1) {
    
            var dcCount = rsBlocks[r].dataCount;
            var ecCount = rsBlocks[r].totalCount - dcCount;
    
            maxDcCount = Math.max(maxDcCount, dcCount);
            maxEcCount = Math.max(maxEcCount, ecCount);
    
            dcdata[r] = new Array(dcCount);
    
            for (var i = 0; i < dcdata[r].length; i += 1) {
              dcdata[r][i] = 0xff & buffer.getBuffer()[i + offset];
            }
            offset += dcCount;
    
            var rsPoly = QRUtil.getErrorCorrectPolynomial(ecCount);
            var rawPoly = qrPolynomial(dcdata[r], rsPoly.getLength() - 1);
    
            var modPoly = rawPoly.mod(rsPoly);
            ecdata[r] = new Array(rsPoly.getLength() - 1);
            for (var i = 0; i < ecdata[r].length; i += 1) {
              var modIndex = i + modPoly.getLength() - ecdata[r].length;
              ecdata[r][i] = (modIndex >= 0)? modPoly.getAt(modIndex) : 0;
            }
          }
    
          var totalCodeCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalCodeCount += rsBlocks[i].totalCount;
          }
    
          var data = new Array(totalCodeCount);
          var index = 0;
    
          for (var i = 0; i < maxDcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < dcdata[r].length) {
                data[index] = dcdata[r][i];
                index += 1;
              }
            }
          }
    
          for (var i = 0; i < maxEcCount; i += 1) {
            for (var r = 0; r < rsBlocks.length; r += 1) {
              if (i < ecdata[r].length) {
                data[index] = ecdata[r][i];
                index += 1;
              }
            }
          }
    
          return data;
        };
    
        var createData = function(typeNumber, errorCorrectionLevel, dataList) {
    
          var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, errorCorrectionLevel);
    
          var buffer = qrBitBuffer();
    
          for (var i = 0; i < dataList.length; i += 1) {
            var data = dataList[i];
            buffer.put(data.getMode(), 4);
            buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
            data.write(buffer);
          }
    
          // calc num max data.
          var totalDataCount = 0;
          for (var i = 0; i < rsBlocks.length; i += 1) {
            totalDataCount += rsBlocks[i].dataCount;
          }
    
          if (buffer.getLengthInBits() > totalDataCount * 8) {
            throw 'code length overflow. ('
              + buffer.getLengthInBits()
              + '>'
              + totalDataCount * 8
              + ')';
          }
    
          // end code
          if (buffer.getLengthInBits() + 4 <= totalDataCount * 8) {
            buffer.put(0, 4);
          }
    
          // padding
          while (buffer.getLengthInBits() % 8 != 0) {
            buffer.putBit(false);
          }
    
          // padding
          while (true) {
    
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD0, 8);
    
            if (buffer.getLengthInBits() >= totalDataCount * 8) {
              break;
            }
            buffer.put(PAD1, 8);
          }
    
          return createBytes(buffer, rsBlocks);
        };
    
        _this.addData = function(data, mode) {
    
          mode = mode || 'Byte';
    
          var newData = null;
    
          switch(mode) {
          case 'Numeric' :
            newData = qrNumber(data);
            break;
          case 'Alphanumeric' :
            newData = qrAlphaNum(data);
            break;
          case 'Byte' :
            newData = qr8BitByte(data);
            break;
          case 'Kanji' :
            newData = qrKanji(data);
            break;
          default :
            throw 'mode:' + mode;
          }
    
          _dataList.push(newData);
          _dataCache = null;
        };
    
        _this.isDark = function(row, col) {
          if (row < 0 || _moduleCount <= row || col < 0 || _moduleCount <= col) {
            throw row + ',' + col;
          }
          return _modules[row][col];
        };
    
        _this.getModuleCount = function() {
          return _moduleCount;
        };
    
        _this.make = function() {
          if (_typeNumber < 1) {
            var typeNumber = 1;
    
            for (; typeNumber < 40; typeNumber++) {
              var rsBlocks = QRRSBlock.getRSBlocks(typeNumber, _errorCorrectionLevel);
              var buffer = qrBitBuffer();
    
              for (var i = 0; i < _dataList.length; i++) {
                var data = _dataList[i];
                buffer.put(data.getMode(), 4);
                buffer.put(data.getLength(), QRUtil.getLengthInBits(data.getMode(), typeNumber) );
                data.write(buffer);
              }
    
              var totalDataCount = 0;
              for (var i = 0; i < rsBlocks.length; i++) {
                totalDataCount += rsBlocks[i].dataCount;
              }
    
              if (buffer.getLengthInBits() <= totalDataCount * 8) {
                break;
              }
            }
    
            _typeNumber = typeNumber;
          }
    
          makeImpl(false, getBestMaskPattern() );
        };
    
        _this.createTableTag = function(cellSize, margin) {
    
          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
    
          var qrHtml = '';
    
          qrHtml += '<table style="';
          qrHtml += ' border-width: 0px; border-style: none;';
          qrHtml += ' border-collapse: collapse;';
          qrHtml += ' padding: 0px; margin: ' + margin + 'px;';
          qrHtml += '">';
          qrHtml += '<tbody>';
    
          for (var r = 0; r < _this.getModuleCount(); r += 1) {
    
            qrHtml += '<tr>';
    
            for (var c = 0; c < _this.getModuleCount(); c += 1) {
              qrHtml += '<td style="';
              qrHtml += ' border-width: 0px; border-style: none;';
              qrHtml += ' border-collapse: collapse;';
              qrHtml += ' padding: 0px; margin: 0px;';
              qrHtml += ' width: ' + cellSize + 'px;';
              qrHtml += ' height: ' + cellSize + 'px;';
              qrHtml += ' background-color: ';
              qrHtml += _this.isDark(r, c)? '#000000' : '#ffffff';
              qrHtml += ';';
              qrHtml += '"/>';
            }
    
            qrHtml += '</tr>';
          }
    
          qrHtml += '</tbody>';
          qrHtml += '</table>';
    
          return qrHtml;
        };
    
        _this.createSvgTag = function(cellSize, margin, alt, title) {
    
          var opts = {};
          if (typeof arguments[0] == 'object') {
            // Called by options.
            opts = arguments[0];
            // overwrite cellSize and margin.
            cellSize = opts.cellSize;
            margin = opts.margin;
            alt = opts.alt;
            title = opts.title;
          }
    
          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
    
          // Compose alt property surrogate
          alt = (typeof alt === 'string') ? {text: alt} : alt || {};
          alt.text = alt.text || null;
          alt.id = (alt.text) ? alt.id || 'qrcode-description' : null;
    
          // Compose title property surrogate
          title = (typeof title === 'string') ? {text: title} : title || {};
          title.text = title.text || null;
          title.id = (title.text) ? title.id || 'qrcode-title' : null;
    
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var c, mc, r, mr, qrSvg='', rect;
    
          rect = 'l' + cellSize + ',0 0,' + cellSize +
            ' -' + cellSize + ',0 0,-' + cellSize + 'z ';
    
          qrSvg += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"';
          qrSvg += !opts.scalable ? ' width="' + size + 'px" height="' + size + 'px"' : '';
          qrSvg += ' viewBox="0 0 ' + size + ' ' + size + '" ';
          qrSvg += ' preserveAspectRatio="xMinYMin meet"';
          qrSvg += (title.text || alt.text) ? ' role="img" aria-labelledby="' +
              escapeXml([title.id, alt.id].join(' ').trim() ) + '"' : '';
          qrSvg += '>';
          qrSvg += (title.text) ? '<title id="' + escapeXml(title.id) + '">' +
              escapeXml(title.text) + '</title>' : '';
          qrSvg += (alt.text) ? '<description id="' + escapeXml(alt.id) + '">' +
              escapeXml(alt.text) + '</description>' : '';
          qrSvg += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>';
          qrSvg += '<path d="';
    
          for (r = 0; r < _this.getModuleCount(); r += 1) {
            mr = r * cellSize + margin;
            for (c = 0; c < _this.getModuleCount(); c += 1) {
              if (_this.isDark(r, c) ) {
                mc = c*cellSize+margin;
                qrSvg += 'M' + mc + ',' + mr + rect;
              }
            }
          }
    
          qrSvg += '" stroke="transparent" fill="black"/>';
          qrSvg += '</svg>';
    
          return qrSvg;
        };
    
        _this.createDataURL = function(cellSize, margin) {
    
          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
    
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
    
          return createDataURL(size, size, function(x, y) {
            if (min <= x && x < max && min <= y && y < max) {
              var c = Math.floor( (x - min) / cellSize);
              var r = Math.floor( (y - min) / cellSize);
              return _this.isDark(r, c)? 0 : 1;
            } else {
              return 1;
            }
          } );
        };
    
        _this.createImgTag = function(cellSize, margin, alt) {
    
          cellSize = cellSize || 2;
          margin = (typeof margin == 'undefined')? cellSize * 4 : margin;
    
          var size = _this.getModuleCount() * cellSize + margin * 2;
    
          var img = '';
          img += '<img';
          img += '\u0020src="';
          img += _this.createDataURL(cellSize, margin);
          img += '"';
          img += '\u0020width="';
          img += size;
          img += '"';
          img += '\u0020height="';
          img += size;
          img += '"';
          if (alt) {
            img += '\u0020alt="';
            img += escapeXml(alt);
            img += '"';
          }
          img += '/>';
    
          return img;
        };
    
        var escapeXml = function(s) {
          var escaped = '';
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charAt(i);
            switch(c) {
            case '<': escaped += '&lt;'; break;
            case '>': escaped += '&gt;'; break;
            case '&': escaped += '&amp;'; break;
            case '"': escaped += '&quot;'; break;
            default : escaped += c; break;
            }
          }
          return escaped;
        };
    
        var _createHalfASCII = function(margin) {
          var cellSize = 1;
          margin = (typeof margin == 'undefined')? cellSize * 2 : margin;
    
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
    
          var y, x, r1, r2, p;
    
          var blocks = {
            '██': '█',
            '█ ': '▀',
            ' █': '▄',
            '  ': ' '
          };
    
          var blocksLastLineNoMargin = {
            '██': '▀',
            '█ ': '▀',
            ' █': ' ',
            '  ': ' '
          };
    
          var ascii = '';
          for (y = 0; y < size; y += 2) {
            r1 = Math.floor((y - min) / cellSize);
            r2 = Math.floor((y + 1 - min) / cellSize);
            for (x = 0; x < size; x += 1) {
              p = '█';
    
              if (min <= x && x < max && min <= y && y < max && _this.isDark(r1, Math.floor((x - min) / cellSize))) {
                p = ' ';
              }
    
              if (min <= x && x < max && min <= y+1 && y+1 < max && _this.isDark(r2, Math.floor((x - min) / cellSize))) {
                p += ' ';
              }
              else {
                p += '█';
              }
    
              // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
              ascii += (margin < 1 && y+1 >= max) ? blocksLastLineNoMargin[p] : blocks[p];
            }
    
            ascii += '\n';
          }
    
          if (size % 2 && margin > 0) {
            return ascii.substring(0, ascii.length - size - 1) + Array(size+1).join('▀');
          }
    
          return ascii.substring(0, ascii.length-1);
        };
    
        _this.createASCII = function(cellSize, margin) {
          cellSize = cellSize || 1;
    
          if (cellSize < 2) {
            return _createHalfASCII(margin);
          }
    
          cellSize -= 1;
          margin = (typeof margin == 'undefined')? cellSize * 2 : margin;
    
          var size = _this.getModuleCount() * cellSize + margin * 2;
          var min = margin;
          var max = size - margin;
    
          var y, x, r, p;
    
          var white = Array(cellSize+1).join('██');
          var black = Array(cellSize+1).join('  ');
    
          var ascii = '';
          var line = '';
          for (y = 0; y < size; y += 1) {
            r = Math.floor( (y - min) / cellSize);
            line = '';
            for (x = 0; x < size; x += 1) {
              p = 1;
    
              if (min <= x && x < max && min <= y && y < max && _this.isDark(r, Math.floor((x - min) / cellSize))) {
                p = 0;
              }
    
              // Output 2 characters per pixel, to create full square. 1 character per pixels gives only half width of square.
              line += p ? white : black;
            }
    
            for (r = 0; r < cellSize; r += 1) {
              ascii += line + '\n';
            }
          }
    
          return ascii.substring(0, ascii.length-1);
        };
    
        _this.renderTo2dContext = function(context, cellSize) {
          cellSize = cellSize || 2;
          var length = _this.getModuleCount();
          for (var row = 0; row < length; row++) {
            for (var col = 0; col < length; col++) {
              context.fillStyle = _this.isDark(row, col) ? 'black' : 'white';
              context.fillRect(row * cellSize, col * cellSize, cellSize, cellSize);
            }
          }
        }
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // qrcode.stringToBytes
      //---------------------------------------------------------------------
    
      qrcode.stringToBytesFuncs = {
        'default' : function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            bytes.push(c & 0xff);
          }
          return bytes;
        }
      };
    
      qrcode.stringToBytes = qrcode.stringToBytesFuncs['default'];
    
      //---------------------------------------------------------------------
      // qrcode.createStringToBytes
      //---------------------------------------------------------------------
    
      /**
       * @param unicodeData base64 string of byte array.
       * [16bit Unicode],[16bit Bytes], ...
       * @param numChars
       */
      qrcode.createStringToBytes = function(unicodeData, numChars) {
    
        // create conversion map.
    
        var unicodeMap = function() {
    
          var bin = base64DecodeInputStream(unicodeData);
          var read = function() {
            var b = bin.read();
            if (b == -1) throw 'eof';
            return b;
          };
    
          var count = 0;
          var unicodeMap = {};
          while (true) {
            var b0 = bin.read();
            if (b0 == -1) break;
            var b1 = read();
            var b2 = read();
            var b3 = read();
            var k = String.fromCharCode( (b0 << 8) | b1);
            var v = (b2 << 8) | b3;
            unicodeMap[k] = v;
            count += 1;
          }
          if (count != numChars) {
            throw count + ' != ' + numChars;
          }
    
          return unicodeMap;
        }();
    
        var unknownChar = '?'.charCodeAt(0);
    
        return function(s) {
          var bytes = [];
          for (var i = 0; i < s.length; i += 1) {
            var c = s.charCodeAt(i);
            if (c < 128) {
              bytes.push(c);
            } else {
              var b = unicodeMap[s.charAt(i)];
              if (typeof b == 'number') {
                if ( (b & 0xff) == b) {
                  // 1byte
                  bytes.push(b);
                } else {
                  // 2bytes
                  bytes.push(b >>> 8);
                  bytes.push(b & 0xff);
                }
              } else {
                bytes.push(unknownChar);
              }
            }
          }
          return bytes;
        };
      };
    
      //---------------------------------------------------------------------
      // QRMode
      //---------------------------------------------------------------------
    
      var QRMode = {
        MODE_NUMBER :    1 << 0,
        MODE_ALPHA_NUM : 1 << 1,
        MODE_8BIT_BYTE : 1 << 2,
        MODE_KANJI :     1 << 3
      };
    
      //---------------------------------------------------------------------
      // QRErrorCorrectionLevel
      //---------------------------------------------------------------------
    
      var QRErrorCorrectionLevel = {
        L : 1,
        M : 0,
        Q : 3,
        H : 2
      };
    
      //---------------------------------------------------------------------
      // QRMaskPattern
      //---------------------------------------------------------------------
    
      var QRMaskPattern = {
        PATTERN000 : 0,
        PATTERN001 : 1,
        PATTERN010 : 2,
        PATTERN011 : 3,
        PATTERN100 : 4,
        PATTERN101 : 5,
        PATTERN110 : 6,
        PATTERN111 : 7
      };
    
      //---------------------------------------------------------------------
      // QRUtil
      //---------------------------------------------------------------------
    
      var QRUtil = function() {
    
        var PATTERN_POSITION_TABLE = [
          [],
          [6, 18],
          [6, 22],
          [6, 26],
          [6, 30],
          [6, 34],
          [6, 22, 38],
          [6, 24, 42],
          [6, 26, 46],
          [6, 28, 50],
          [6, 30, 54],
          [6, 32, 58],
          [6, 34, 62],
          [6, 26, 46, 66],
          [6, 26, 48, 70],
          [6, 26, 50, 74],
          [6, 30, 54, 78],
          [6, 30, 56, 82],
          [6, 30, 58, 86],
          [6, 34, 62, 90],
          [6, 28, 50, 72, 94],
          [6, 26, 50, 74, 98],
          [6, 30, 54, 78, 102],
          [6, 28, 54, 80, 106],
          [6, 32, 58, 84, 110],
          [6, 30, 58, 86, 114],
          [6, 34, 62, 90, 118],
          [6, 26, 50, 74, 98, 122],
          [6, 30, 54, 78, 102, 126],
          [6, 26, 52, 78, 104, 130],
          [6, 30, 56, 82, 108, 134],
          [6, 34, 60, 86, 112, 138],
          [6, 30, 58, 86, 114, 142],
          [6, 34, 62, 90, 118, 146],
          [6, 30, 54, 78, 102, 126, 150],
          [6, 24, 50, 76, 102, 128, 154],
          [6, 28, 54, 80, 106, 132, 158],
          [6, 32, 58, 84, 110, 136, 162],
          [6, 26, 54, 82, 110, 138, 166],
          [6, 30, 58, 86, 114, 142, 170]
        ];
        var G15 = (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0);
        var G18 = (1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8) | (1 << 5) | (1 << 2) | (1 << 0);
        var G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1);
    
        var _this = {};
    
        var getBCHDigit = function(data) {
          var digit = 0;
          while (data != 0) {
            digit += 1;
            data >>>= 1;
          }
          return digit;
        };
    
        _this.getBCHTypeInfo = function(data) {
          var d = data << 10;
          while (getBCHDigit(d) - getBCHDigit(G15) >= 0) {
            d ^= (G15 << (getBCHDigit(d) - getBCHDigit(G15) ) );
          }
          return ( (data << 10) | d) ^ G15_MASK;
        };
    
        _this.getBCHTypeNumber = function(data) {
          var d = data << 12;
          while (getBCHDigit(d) - getBCHDigit(G18) >= 0) {
            d ^= (G18 << (getBCHDigit(d) - getBCHDigit(G18) ) );
          }
          return (data << 12) | d;
        };
    
        _this.getPatternPosition = function(typeNumber) {
          return PATTERN_POSITION_TABLE[typeNumber - 1];
        };
    
        _this.getMaskFunction = function(maskPattern) {
    
          switch (maskPattern) {
    
          case QRMaskPattern.PATTERN000 :
            return function(i, j) { return (i + j) % 2 == 0; };
          case QRMaskPattern.PATTERN001 :
            return function(i, j) { return i % 2 == 0; };
          case QRMaskPattern.PATTERN010 :
            return function(i, j) { return j % 3 == 0; };
          case QRMaskPattern.PATTERN011 :
            return function(i, j) { return (i + j) % 3 == 0; };
          case QRMaskPattern.PATTERN100 :
            return function(i, j) { return (Math.floor(i / 2) + Math.floor(j / 3) ) % 2 == 0; };
          case QRMaskPattern.PATTERN101 :
            return function(i, j) { return (i * j) % 2 + (i * j) % 3 == 0; };
          case QRMaskPattern.PATTERN110 :
            return function(i, j) { return ( (i * j) % 2 + (i * j) % 3) % 2 == 0; };
          case QRMaskPattern.PATTERN111 :
            return function(i, j) { return ( (i * j) % 3 + (i + j) % 2) % 2 == 0; };
    
          default :
            throw 'bad maskPattern:' + maskPattern;
          }
        };
    
        _this.getErrorCorrectPolynomial = function(errorCorrectLength) {
          var a = qrPolynomial([1], 0);
          for (var i = 0; i < errorCorrectLength; i += 1) {
            a = a.multiply(qrPolynomial([1, QRMath.gexp(i)], 0) );
          }
          return a;
        };
    
        _this.getLengthInBits = function(mode, type) {
    
          if (1 <= type && type < 10) {
    
            // 1 - 9
    
            switch(mode) {
            case QRMode.MODE_NUMBER    : return 10;
            case QRMode.MODE_ALPHA_NUM : return 9;
            case QRMode.MODE_8BIT_BYTE : return 8;
            case QRMode.MODE_KANJI     : return 8;
            default :
              throw 'mode:' + mode;
            }
    
          } else if (type < 27) {
    
            // 10 - 26
    
            switch(mode) {
            case QRMode.MODE_NUMBER    : return 12;
            case QRMode.MODE_ALPHA_NUM : return 11;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 10;
            default :
              throw 'mode:' + mode;
            }
    
          } else if (type < 41) {
    
            // 27 - 40
    
            switch(mode) {
            case QRMode.MODE_NUMBER    : return 14;
            case QRMode.MODE_ALPHA_NUM : return 13;
            case QRMode.MODE_8BIT_BYTE : return 16;
            case QRMode.MODE_KANJI     : return 12;
            default :
              throw 'mode:' + mode;
            }
    
          } else {
            throw 'type:' + type;
          }
        };
    
        _this.getLostPoint = function(qrcode) {
    
          var moduleCount = qrcode.getModuleCount();
    
          var lostPoint = 0;
    
          // LEVEL1
    
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount; col += 1) {
    
              var sameCount = 0;
              var dark = qrcode.isDark(row, col);
    
              for (var r = -1; r <= 1; r += 1) {
    
                if (row + r < 0 || moduleCount <= row + r) {
                  continue;
                }
    
                for (var c = -1; c <= 1; c += 1) {
    
                  if (col + c < 0 || moduleCount <= col + c) {
                    continue;
                  }
    
                  if (r == 0 && c == 0) {
                    continue;
                  }
    
                  if (dark == qrcode.isDark(row + r, col + c) ) {
                    sameCount += 1;
                  }
                }
              }
    
              if (sameCount > 5) {
                lostPoint += (3 + sameCount - 5);
              }
            }
          };
    
          // LEVEL2
    
          for (var row = 0; row < moduleCount - 1; row += 1) {
            for (var col = 0; col < moduleCount - 1; col += 1) {
              var count = 0;
              if (qrcode.isDark(row, col) ) count += 1;
              if (qrcode.isDark(row + 1, col) ) count += 1;
              if (qrcode.isDark(row, col + 1) ) count += 1;
              if (qrcode.isDark(row + 1, col + 1) ) count += 1;
              if (count == 0 || count == 4) {
                lostPoint += 3;
              }
            }
          }
    
          // LEVEL3
    
          for (var row = 0; row < moduleCount; row += 1) {
            for (var col = 0; col < moduleCount - 6; col += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row, col + 1)
                  &&  qrcode.isDark(row, col + 2)
                  &&  qrcode.isDark(row, col + 3)
                  &&  qrcode.isDark(row, col + 4)
                  && !qrcode.isDark(row, col + 5)
                  &&  qrcode.isDark(row, col + 6) ) {
                lostPoint += 40;
              }
            }
          }
    
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount - 6; row += 1) {
              if (qrcode.isDark(row, col)
                  && !qrcode.isDark(row + 1, col)
                  &&  qrcode.isDark(row + 2, col)
                  &&  qrcode.isDark(row + 3, col)
                  &&  qrcode.isDark(row + 4, col)
                  && !qrcode.isDark(row + 5, col)
                  &&  qrcode.isDark(row + 6, col) ) {
                lostPoint += 40;
              }
            }
          }
    
          // LEVEL4
    
          var darkCount = 0;
    
          for (var col = 0; col < moduleCount; col += 1) {
            for (var row = 0; row < moduleCount; row += 1) {
              if (qrcode.isDark(row, col) ) {
                darkCount += 1;
              }
            }
          }
    
          var ratio = Math.abs(100 * darkCount / moduleCount / moduleCount - 50) / 5;
          lostPoint += ratio * 10;
    
          return lostPoint;
        };
    
        return _this;
      }();
    
      //---------------------------------------------------------------------
      // QRMath
      //---------------------------------------------------------------------
    
      var QRMath = function() {
    
        var EXP_TABLE = new Array(256);
        var LOG_TABLE = new Array(256);
    
        // initialize tables
        for (var i = 0; i < 8; i += 1) {
          EXP_TABLE[i] = 1 << i;
        }
        for (var i = 8; i < 256; i += 1) {
          EXP_TABLE[i] = EXP_TABLE[i - 4]
            ^ EXP_TABLE[i - 5]
            ^ EXP_TABLE[i - 6]
            ^ EXP_TABLE[i - 8];
        }
        for (var i = 0; i < 255; i += 1) {
          LOG_TABLE[EXP_TABLE[i] ] = i;
        }
    
        var _this = {};
    
        _this.glog = function(n) {
    
          if (n < 1) {
            throw 'glog(' + n + ')';
          }
    
          return LOG_TABLE[n];
        };
    
        _this.gexp = function(n) {
    
          while (n < 0) {
            n += 255;
          }
    
          while (n >= 256) {
            n -= 255;
          }
    
          return EXP_TABLE[n];
        };
    
        return _this;
      }();
    
      //---------------------------------------------------------------------
      // qrPolynomial
      //---------------------------------------------------------------------
    
      function qrPolynomial(num, shift) {
    
        if (typeof num.length == 'undefined') {
          throw num.length + '/' + shift;
        }
    
        var _num = function() {
          var offset = 0;
          while (offset < num.length && num[offset] == 0) {
            offset += 1;
          }
          var _num = new Array(num.length - offset + shift);
          for (var i = 0; i < num.length - offset; i += 1) {
            _num[i] = num[i + offset];
          }
          return _num;
        }();
    
        var _this = {};
    
        _this.getAt = function(index) {
          return _num[index];
        };
    
        _this.getLength = function() {
          return _num.length;
        };
    
        _this.multiply = function(e) {
    
          var num = new Array(_this.getLength() + e.getLength() - 1);
    
          for (var i = 0; i < _this.getLength(); i += 1) {
            for (var j = 0; j < e.getLength(); j += 1) {
              num[i + j] ^= QRMath.gexp(QRMath.glog(_this.getAt(i) ) + QRMath.glog(e.getAt(j) ) );
            }
          }
    
          return qrPolynomial(num, 0);
        };
    
        _this.mod = function(e) {
    
          if (_this.getLength() - e.getLength() < 0) {
            return _this;
          }
    
          var ratio = QRMath.glog(_this.getAt(0) ) - QRMath.glog(e.getAt(0) );
    
          var num = new Array(_this.getLength() );
          for (var i = 0; i < _this.getLength(); i += 1) {
            num[i] = _this.getAt(i);
          }
    
          for (var i = 0; i < e.getLength(); i += 1) {
            num[i] ^= QRMath.gexp(QRMath.glog(e.getAt(i) ) + ratio);
          }
    
          // recursive call
          return qrPolynomial(num, 0).mod(e);
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // QRRSBlock
      //---------------------------------------------------------------------
    
      var QRRSBlock = function() {
    
        var RS_BLOCK_TABLE = [
    
          // L
          // M
          // Q
          // H
    
          // 1
          [1, 26, 19],
          [1, 26, 16],
          [1, 26, 13],
          [1, 26, 9],
    
          // 2
          [1, 44, 34],
          [1, 44, 28],
          [1, 44, 22],
          [1, 44, 16],
    
          // 3
          [1, 70, 55],
          [1, 70, 44],
          [2, 35, 17],
          [2, 35, 13],
    
          // 4
          [1, 100, 80],
          [2, 50, 32],
          [2, 50, 24],
          [4, 25, 9],
    
          // 5
          [1, 134, 108],
          [2, 67, 43],
          [2, 33, 15, 2, 34, 16],
          [2, 33, 11, 2, 34, 12],
    
          // 6
          [2, 86, 68],
          [4, 43, 27],
          [4, 43, 19],
          [4, 43, 15],
    
          // 7
          [2, 98, 78],
          [4, 49, 31],
          [2, 32, 14, 4, 33, 15],
          [4, 39, 13, 1, 40, 14],
    
          // 8
          [2, 121, 97],
          [2, 60, 38, 2, 61, 39],
          [4, 40, 18, 2, 41, 19],
          [4, 40, 14, 2, 41, 15],
    
          // 9
          [2, 146, 116],
          [3, 58, 36, 2, 59, 37],
          [4, 36, 16, 4, 37, 17],
          [4, 36, 12, 4, 37, 13],
    
          // 10
          [2, 86, 68, 2, 87, 69],
          [4, 69, 43, 1, 70, 44],
          [6, 43, 19, 2, 44, 20],
          [6, 43, 15, 2, 44, 16],
    
          // 11
          [4, 101, 81],
          [1, 80, 50, 4, 81, 51],
          [4, 50, 22, 4, 51, 23],
          [3, 36, 12, 8, 37, 13],
    
          // 12
          [2, 116, 92, 2, 117, 93],
          [6, 58, 36, 2, 59, 37],
          [4, 46, 20, 6, 47, 21],
          [7, 42, 14, 4, 43, 15],
    
          // 13
          [4, 133, 107],
          [8, 59, 37, 1, 60, 38],
          [8, 44, 20, 4, 45, 21],
          [12, 33, 11, 4, 34, 12],
    
          // 14
          [3, 145, 115, 1, 146, 116],
          [4, 64, 40, 5, 65, 41],
          [11, 36, 16, 5, 37, 17],
          [11, 36, 12, 5, 37, 13],
    
          // 15
          [5, 109, 87, 1, 110, 88],
          [5, 65, 41, 5, 66, 42],
          [5, 54, 24, 7, 55, 25],
          [11, 36, 12, 7, 37, 13],
    
          // 16
          [5, 122, 98, 1, 123, 99],
          [7, 73, 45, 3, 74, 46],
          [15, 43, 19, 2, 44, 20],
          [3, 45, 15, 13, 46, 16],
    
          // 17
          [1, 135, 107, 5, 136, 108],
          [10, 74, 46, 1, 75, 47],
          [1, 50, 22, 15, 51, 23],
          [2, 42, 14, 17, 43, 15],
    
          // 18
          [5, 150, 120, 1, 151, 121],
          [9, 69, 43, 4, 70, 44],
          [17, 50, 22, 1, 51, 23],
          [2, 42, 14, 19, 43, 15],
    
          // 19
          [3, 141, 113, 4, 142, 114],
          [3, 70, 44, 11, 71, 45],
          [17, 47, 21, 4, 48, 22],
          [9, 39, 13, 16, 40, 14],
    
          // 20
          [3, 135, 107, 5, 136, 108],
          [3, 67, 41, 13, 68, 42],
          [15, 54, 24, 5, 55, 25],
          [15, 43, 15, 10, 44, 16],
    
          // 21
          [4, 144, 116, 4, 145, 117],
          [17, 68, 42],
          [17, 50, 22, 6, 51, 23],
          [19, 46, 16, 6, 47, 17],
    
          // 22
          [2, 139, 111, 7, 140, 112],
          [17, 74, 46],
          [7, 54, 24, 16, 55, 25],
          [34, 37, 13],
    
          // 23
          [4, 151, 121, 5, 152, 122],
          [4, 75, 47, 14, 76, 48],
          [11, 54, 24, 14, 55, 25],
          [16, 45, 15, 14, 46, 16],
    
          // 24
          [6, 147, 117, 4, 148, 118],
          [6, 73, 45, 14, 74, 46],
          [11, 54, 24, 16, 55, 25],
          [30, 46, 16, 2, 47, 17],
    
          // 25
          [8, 132, 106, 4, 133, 107],
          [8, 75, 47, 13, 76, 48],
          [7, 54, 24, 22, 55, 25],
          [22, 45, 15, 13, 46, 16],
    
          // 26
          [10, 142, 114, 2, 143, 115],
          [19, 74, 46, 4, 75, 47],
          [28, 50, 22, 6, 51, 23],
          [33, 46, 16, 4, 47, 17],
    
          // 27
          [8, 152, 122, 4, 153, 123],
          [22, 73, 45, 3, 74, 46],
          [8, 53, 23, 26, 54, 24],
          [12, 45, 15, 28, 46, 16],
    
          // 28
          [3, 147, 117, 10, 148, 118],
          [3, 73, 45, 23, 74, 46],
          [4, 54, 24, 31, 55, 25],
          [11, 45, 15, 31, 46, 16],
    
          // 29
          [7, 146, 116, 7, 147, 117],
          [21, 73, 45, 7, 74, 46],
          [1, 53, 23, 37, 54, 24],
          [19, 45, 15, 26, 46, 16],
    
          // 30
          [5, 145, 115, 10, 146, 116],
          [19, 75, 47, 10, 76, 48],
          [15, 54, 24, 25, 55, 25],
          [23, 45, 15, 25, 46, 16],
    
          // 31
          [13, 145, 115, 3, 146, 116],
          [2, 74, 46, 29, 75, 47],
          [42, 54, 24, 1, 55, 25],
          [23, 45, 15, 28, 46, 16],
    
          // 32
          [17, 145, 115],
          [10, 74, 46, 23, 75, 47],
          [10, 54, 24, 35, 55, 25],
          [19, 45, 15, 35, 46, 16],
    
          // 33
          [17, 145, 115, 1, 146, 116],
          [14, 74, 46, 21, 75, 47],
          [29, 54, 24, 19, 55, 25],
          [11, 45, 15, 46, 46, 16],
    
          // 34
          [13, 145, 115, 6, 146, 116],
          [14, 74, 46, 23, 75, 47],
          [44, 54, 24, 7, 55, 25],
          [59, 46, 16, 1, 47, 17],
    
          // 35
          [12, 151, 121, 7, 152, 122],
          [12, 75, 47, 26, 76, 48],
          [39, 54, 24, 14, 55, 25],
          [22, 45, 15, 41, 46, 16],
    
          // 36
          [6, 151, 121, 14, 152, 122],
          [6, 75, 47, 34, 76, 48],
          [46, 54, 24, 10, 55, 25],
          [2, 45, 15, 64, 46, 16],
    
          // 37
          [17, 152, 122, 4, 153, 123],
          [29, 74, 46, 14, 75, 47],
          [49, 54, 24, 10, 55, 25],
          [24, 45, 15, 46, 46, 16],
    
          // 38
          [4, 152, 122, 18, 153, 123],
          [13, 74, 46, 32, 75, 47],
          [48, 54, 24, 14, 55, 25],
          [42, 45, 15, 32, 46, 16],
    
          // 39
          [20, 147, 117, 4, 148, 118],
          [40, 75, 47, 7, 76, 48],
          [43, 54, 24, 22, 55, 25],
          [10, 45, 15, 67, 46, 16],
    
          // 40
          [19, 148, 118, 6, 149, 119],
          [18, 75, 47, 31, 76, 48],
          [34, 54, 24, 34, 55, 25],
          [20, 45, 15, 61, 46, 16]
        ];
    
        var qrRSBlock = function(totalCount, dataCount) {
          var _this = {};
          _this.totalCount = totalCount;
          _this.dataCount = dataCount;
          return _this;
        };
    
        var _this = {};
    
        var getRsBlockTable = function(typeNumber, errorCorrectionLevel) {
    
          switch(errorCorrectionLevel) {
          case QRErrorCorrectionLevel.L :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 0];
          case QRErrorCorrectionLevel.M :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 1];
          case QRErrorCorrectionLevel.Q :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 2];
          case QRErrorCorrectionLevel.H :
            return RS_BLOCK_TABLE[(typeNumber - 1) * 4 + 3];
          default :
            return undefined;
          }
        };
    
        _this.getRSBlocks = function(typeNumber, errorCorrectionLevel) {
    
          var rsBlock = getRsBlockTable(typeNumber, errorCorrectionLevel);
    
          if (typeof rsBlock == 'undefined') {
            throw 'bad rs block @ typeNumber:' + typeNumber +
                '/errorCorrectionLevel:' + errorCorrectionLevel;
          }
    
          var length = rsBlock.length / 3;
    
          var list = [];
    
          for (var i = 0; i < length; i += 1) {
    
            var count = rsBlock[i * 3 + 0];
            var totalCount = rsBlock[i * 3 + 1];
            var dataCount = rsBlock[i * 3 + 2];
    
            for (var j = 0; j < count; j += 1) {
              list.push(qrRSBlock(totalCount, dataCount) );
            }
          }
    
          return list;
        };
    
        return _this;
      }();
    
      //---------------------------------------------------------------------
      // qrBitBuffer
      //---------------------------------------------------------------------
    
      var qrBitBuffer = function() {
    
        var _buffer = [];
        var _length = 0;
    
        var _this = {};
    
        _this.getBuffer = function() {
          return _buffer;
        };
    
        _this.getAt = function(index) {
          var bufIndex = Math.floor(index / 8);
          return ( (_buffer[bufIndex] >>> (7 - index % 8) ) & 1) == 1;
        };
    
        _this.put = function(num, length) {
          for (var i = 0; i < length; i += 1) {
            _this.putBit( ( (num >>> (length - i - 1) ) & 1) == 1);
          }
        };
    
        _this.getLengthInBits = function() {
          return _length;
        };
    
        _this.putBit = function(bit) {
    
          var bufIndex = Math.floor(_length / 8);
          if (_buffer.length <= bufIndex) {
            _buffer.push(0);
          }
    
          if (bit) {
            _buffer[bufIndex] |= (0x80 >>> (_length % 8) );
          }
    
          _length += 1;
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // qrNumber
      //---------------------------------------------------------------------
    
      var qrNumber = function(data) {
    
        var _mode = QRMode.MODE_NUMBER;
        var _data = data;
    
        var _this = {};
    
        _this.getMode = function() {
          return _mode;
        };
    
        _this.getLength = function(buffer) {
          return _data.length;
        };
    
        _this.write = function(buffer) {
    
          var data = _data;
    
          var i = 0;
    
          while (i + 2 < data.length) {
            buffer.put(strToNum(data.substring(i, i + 3) ), 10);
            i += 3;
          }
    
          if (i < data.length) {
            if (data.length - i == 1) {
              buffer.put(strToNum(data.substring(i, i + 1) ), 4);
            } else if (data.length - i == 2) {
              buffer.put(strToNum(data.substring(i, i + 2) ), 7);
            }
          }
        };
    
        var strToNum = function(s) {
          var num = 0;
          for (var i = 0; i < s.length; i += 1) {
            num = num * 10 + chatToNum(s.charAt(i) );
          }
          return num;
        };
    
        var chatToNum = function(c) {
          if ('0' <= c && c <= '9') {
            return c.charCodeAt(0) - '0'.charCodeAt(0);
          }
          throw 'illegal char :' + c;
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // qrAlphaNum
      //---------------------------------------------------------------------
    
      var qrAlphaNum = function(data) {
    
        var _mode = QRMode.MODE_ALPHA_NUM;
        var _data = data;
    
        var _this = {};
    
        _this.getMode = function() {
          return _mode;
        };
    
        _this.getLength = function(buffer) {
          return _data.length;
        };
    
        _this.write = function(buffer) {
    
          var s = _data;
    
          var i = 0;
    
          while (i + 1 < s.length) {
            buffer.put(
              getCode(s.charAt(i) ) * 45 +
              getCode(s.charAt(i + 1) ), 11);
            i += 2;
          }
    
          if (i < s.length) {
            buffer.put(getCode(s.charAt(i) ), 6);
          }
        };
    
        var getCode = function(c) {
    
          if ('0' <= c && c <= '9') {
            return c.charCodeAt(0) - '0'.charCodeAt(0);
          } else if ('A' <= c && c <= 'Z') {
            return c.charCodeAt(0) - 'A'.charCodeAt(0) + 10;
          } else {
            switch (c) {
            case ' ' : return 36;
            case '$' : return 37;
            case '%' : return 38;
            case '*' : return 39;
            case '+' : return 40;
            case '-' : return 41;
            case '.' : return 42;
            case '/' : return 43;
            case ':' : return 44;
            default :
              throw 'illegal char :' + c;
            }
          }
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // qr8BitByte
      //---------------------------------------------------------------------
    
      var qr8BitByte = function(data) {
    
        var _mode = QRMode.MODE_8BIT_BYTE;
        var _data = data;
        var _bytes = qrcode.stringToBytes(data);
    
        var _this = {};
    
        _this.getMode = function() {
          return _mode;
        };
    
        _this.getLength = function(buffer) {
          return _bytes.length;
        };
    
        _this.write = function(buffer) {
          for (var i = 0; i < _bytes.length; i += 1) {
            buffer.put(_bytes[i], 8);
          }
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // qrKanji
      //---------------------------------------------------------------------
    
      var qrKanji = function(data) {
    
        var _mode = QRMode.MODE_KANJI;
        var _data = data;
    
        var stringToBytes = qrcode.stringToBytesFuncs['SJIS'];
        if (!stringToBytes) {
          throw 'sjis not supported.';
        }
        !function(c, code) {
          // self test for sjis support.
          var test = stringToBytes(c);
          if (test.length != 2 || ( (test[0] << 8) | test[1]) != code) {
            throw 'sjis not supported.';
          }
        }('\u53cb', 0x9746);
    
        var _bytes = stringToBytes(data);
    
        var _this = {};
    
        _this.getMode = function() {
          return _mode;
        };
    
        _this.getLength = function(buffer) {
          return ~~(_bytes.length / 2);
        };
    
        _this.write = function(buffer) {
    
          var data = _bytes;
    
          var i = 0;
    
          while (i + 1 < data.length) {
    
            var c = ( (0xff & data[i]) << 8) | (0xff & data[i + 1]);
    
            if (0x8140 <= c && c <= 0x9FFC) {
              c -= 0x8140;
            } else if (0xE040 <= c && c <= 0xEBBF) {
              c -= 0xC140;
            } else {
              throw 'illegal char at ' + (i + 1) + '/' + c;
            }
    
            c = ( (c >>> 8) & 0xff) * 0xC0 + (c & 0xff);
    
            buffer.put(c, 13);
    
            i += 2;
          }
    
          if (i < data.length) {
            throw 'illegal char at ' + (i + 1);
          }
        };
    
        return _this;
      };
    
      //=====================================================================
      // GIF Support etc.
      //
    
      //---------------------------------------------------------------------
      // byteArrayOutputStream
      //---------------------------------------------------------------------
    
      var byteArrayOutputStream = function() {
    
        var _bytes = [];
    
        var _this = {};
    
        _this.writeByte = function(b) {
          _bytes.push(b & 0xff);
        };
    
        _this.writeShort = function(i) {
          _this.writeByte(i);
          _this.writeByte(i >>> 8);
        };
    
        _this.writeBytes = function(b, off, len) {
          off = off || 0;
          len = len || b.length;
          for (var i = 0; i < len; i += 1) {
            _this.writeByte(b[i + off]);
          }
        };
    
        _this.writeString = function(s) {
          for (var i = 0; i < s.length; i += 1) {
            _this.writeByte(s.charCodeAt(i) );
          }
        };
    
        _this.toByteArray = function() {
          return _bytes;
        };
    
        _this.toString = function() {
          var s = '';
          s += '[';
          for (var i = 0; i < _bytes.length; i += 1) {
            if (i > 0) {
              s += ',';
            }
            s += _bytes[i];
          }
          s += ']';
          return s;
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // base64EncodeOutputStream
      //---------------------------------------------------------------------
    
      var base64EncodeOutputStream = function() {
    
        var _buffer = 0;
        var _buflen = 0;
        var _length = 0;
        var _base64 = '';
    
        var _this = {};
    
        var writeEncoded = function(b) {
          _base64 += String.fromCharCode(encode(b & 0x3f) );
        };
    
        var encode = function(n) {
          if (n < 0) {
            // error.
          } else if (n < 26) {
            return 0x41 + n;
          } else if (n < 52) {
            return 0x61 + (n - 26);
          } else if (n < 62) {
            return 0x30 + (n - 52);
          } else if (n == 62) {
            return 0x2b;
          } else if (n == 63) {
            return 0x2f;
          }
          throw 'n:' + n;
        };
    
        _this.writeByte = function(n) {
    
          _buffer = (_buffer << 8) | (n & 0xff);
          _buflen += 8;
          _length += 1;
    
          while (_buflen >= 6) {
            writeEncoded(_buffer >>> (_buflen - 6) );
            _buflen -= 6;
          }
        };
    
        _this.flush = function() {
    
          if (_buflen > 0) {
            writeEncoded(_buffer << (6 - _buflen) );
            _buffer = 0;
            _buflen = 0;
          }
    
          if (_length % 3 != 0) {
            // padding
            var padlen = 3 - _length % 3;
            for (var i = 0; i < padlen; i += 1) {
              _base64 += '=';
            }
          }
        };
    
        _this.toString = function() {
          return _base64;
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // base64DecodeInputStream
      //---------------------------------------------------------------------
    
      var base64DecodeInputStream = function(str) {
    
        var _str = str;
        var _pos = 0;
        var _buffer = 0;
        var _buflen = 0;
    
        var _this = {};
    
        _this.read = function() {
    
          while (_buflen < 8) {
    
            if (_pos >= _str.length) {
              if (_buflen == 0) {
                return -1;
              }
              throw 'unexpected end of file./' + _buflen;
            }
    
            var c = _str.charAt(_pos);
            _pos += 1;
    
            if (c == '=') {
              _buflen = 0;
              return -1;
            } else if (c.match(/^\s$/) ) {
              // ignore if whitespace.
              continue;
            }
    
            _buffer = (_buffer << 6) | decode(c.charCodeAt(0) );
            _buflen += 6;
          }
    
          var n = (_buffer >>> (_buflen - 8) ) & 0xff;
          _buflen -= 8;
          return n;
        };
    
        var decode = function(c) {
          if (0x41 <= c && c <= 0x5a) {
            return c - 0x41;
          } else if (0x61 <= c && c <= 0x7a) {
            return c - 0x61 + 26;
          } else if (0x30 <= c && c <= 0x39) {
            return c - 0x30 + 52;
          } else if (c == 0x2b) {
            return 62;
          } else if (c == 0x2f) {
            return 63;
          } else {
            throw 'c:' + c;
          }
        };
    
        return _this;
      };
    
      //---------------------------------------------------------------------
      // gifImage (B/W)
      //---------------------------------------------------------------------
    
      var gifImage = function(width, height) {
    
        var _width = width;
        var _height = height;
        var _data = new Array(width * height);
    
        var _this = {};
    
        _this.setPixel = function(x, y, pixel) {
          _data[y * _width + x] = pixel;
        };
    
        _this.write = function(out) {
    
          //---------------------------------
          // GIF Signature
    
          out.writeString('GIF87a');
    
          //---------------------------------
          // Screen Descriptor
    
          out.writeShort(_width);
          out.writeShort(_height);
    
          out.writeByte(0x80); // 2bit
          out.writeByte(0);
          out.writeByte(0);
    
          //---------------------------------
          // Global Color Map
    
          // black
          out.writeByte(0x00);
          out.writeByte(0x00);
          out.writeByte(0x00);
    
          // white
          out.writeByte(0xff);
          out.writeByte(0xff);
          out.writeByte(0xff);
    
          //---------------------------------
          // Image Descriptor
    
          out.writeString(',');
          out.writeShort(0);
          out.writeShort(0);
          out.writeShort(_width);
          out.writeShort(_height);
          out.writeByte(0);
    
          //---------------------------------
          // Local Color Map
    
          //---------------------------------
          // Raster Data
    
          var lzwMinCodeSize = 2;
          var raster = getLZWRaster(lzwMinCodeSize);
    
          out.writeByte(lzwMinCodeSize);
    
          var offset = 0;
    
          while (raster.length - offset > 255) {
            out.writeByte(255);
            out.writeBytes(raster, offset, 255);
            offset += 255;
          }
    
          out.writeByte(raster.length - offset);
          out.writeBytes(raster, offset, raster.length - offset);
          out.writeByte(0x00);
    
          //---------------------------------
          // GIF Terminator
          out.writeString(';');
        };
    
        var bitOutputStream = function(out) {
    
          var _out = out;
          var _bitLength = 0;
          var _bitBuffer = 0;
    
          var _this = {};
    
          _this.write = function(data, length) {
    
            if ( (data >>> length) != 0) {
              throw 'length over';
            }
    
            while (_bitLength + length >= 8) {
              _out.writeByte(0xff & ( (data << _bitLength) | _bitBuffer) );
              length -= (8 - _bitLength);
              data >>>= (8 - _bitLength);
              _bitBuffer = 0;
              _bitLength = 0;
            }
    
            _bitBuffer = (data << _bitLength) | _bitBuffer;
            _bitLength = _bitLength + length;
          };
    
          _this.flush = function() {
            if (_bitLength > 0) {
              _out.writeByte(_bitBuffer);
            }
          };
    
          return _this;
        };
    
        var getLZWRaster = function(lzwMinCodeSize) {
    
          var clearCode = 1 << lzwMinCodeSize;
          var endCode = (1 << lzwMinCodeSize) + 1;
          var bitLength = lzwMinCodeSize + 1;
    
          // Setup LZWTable
          var table = lzwTable();
    
          for (var i = 0; i < clearCode; i += 1) {
            table.add(String.fromCharCode(i) );
          }
          table.add(String.fromCharCode(clearCode) );
          table.add(String.fromCharCode(endCode) );
    
          var byteOut = byteArrayOutputStream();
          var bitOut = bitOutputStream(byteOut);
    
          // clear code
          bitOut.write(clearCode, bitLength);
    
          var dataIndex = 0;
    
          var s = String.fromCharCode(_data[dataIndex]);
          dataIndex += 1;
    
          while (dataIndex < _data.length) {
    
            var c = String.fromCharCode(_data[dataIndex]);
            dataIndex += 1;
    
            if (table.contains(s + c) ) {
    
              s = s + c;
    
            } else {
    
              bitOut.write(table.indexOf(s), bitLength);
    
              if (table.size() < 0xfff) {
    
                if (table.size() == (1 << bitLength) ) {
                  bitLength += 1;
                }
    
                table.add(s + c);
              }
    
              s = c;
            }
          }
    
          bitOut.write(table.indexOf(s), bitLength);
    
          // end code
          bitOut.write(endCode, bitLength);
    
          bitOut.flush();
    
          return byteOut.toByteArray();
        };
    
        var lzwTable = function() {
    
          var _map = {};
          var _size = 0;
    
          var _this = {};
    
          _this.add = function(key) {
            if (_this.contains(key) ) {
              throw 'dup key:' + key;
            }
            _map[key] = _size;
            _size += 1;
          };
    
          _this.size = function() {
            return _size;
          };
    
          _this.indexOf = function(key) {
            return _map[key];
          };
    
          _this.contains = function(key) {
            return typeof _map[key] != 'undefined';
          };
    
          return _this;
        };
    
        return _this;
      };
    
      var createDataURL = function(width, height, getPixel) {
        var gif = gifImage(width, height);
        for (var y = 0; y < height; y += 1) {
          for (var x = 0; x < width; x += 1) {
            gif.setPixel(x, y, getPixel(x, y) );
          }
        }
    
        var b = byteArrayOutputStream();
        gif.write(b);
    
        var base64 = base64EncodeOutputStream();
        var bytes = b.toByteArray();
        for (var i = 0; i < bytes.length; i += 1) {
          base64.writeByte(bytes[i]);
        }
        base64.flush();
    
        return 'data:image/gif;base64,' + base64;
      };
    
      //---------------------------------------------------------------------
      // returns qrcode function.
    
      return qrcode;
    }();
    
    // multibyte support
    !function() {
    
      qrcode.stringToBytesFuncs['UTF-8'] = function(s) {
        // http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
        function toUTF8Array(str) {
          var utf8 = [];
          for (var i=0; i < str.length; i++) {
            var charcode = str.charCodeAt(i);
            if (charcode < 0x80) utf8.push(charcode);
            else if (charcode < 0x800) {
              utf8.push(0xc0 | (charcode >> 6),
                  0x80 | (charcode & 0x3f));
            }
            else if (charcode < 0xd800 || charcode >= 0xe000) {
              utf8.push(0xe0 | (charcode >> 12),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
            // surrogate pair
            else {
              i++;
              // UTF-16 encodes 0x10000-0x10FFFF by
              // subtracting 0x10000 and splitting the
              // 20 bits of 0x0-0xFFFFF into two halves
              charcode = 0x10000 + (((charcode & 0x3ff)<<10)
                | (str.charCodeAt(i) & 0x3ff));
              utf8.push(0xf0 | (charcode >>18),
                  0x80 | ((charcode>>12) & 0x3f),
                  0x80 | ((charcode>>6) & 0x3f),
                  0x80 | (charcode & 0x3f));
            }
          }
          return utf8;
        }
        return toUTF8Array(s);
      };
    
    }();
    
    (function (factory) {
      if (typeof define === 'function' && define.amd) {
          define([], factory);
      } else if (typeof exports === 'object') {
          module.exports = factory();
      }
    }(function () {
        return qrcode;
    }));
    //---------------------------------------------------------------------
    //
    // QR Code Generator for JavaScript UTF8 Support (optional)
    //
    // Copyright (c) 2011 Kazuhiko Arase
    //
    // URL: http://www.d-project.com/
    //
    // Licensed under the MIT license:
    //  http://www.opensource.org/licenses/mit-license.php
    //
    // The word 'QR Code' is registered trademark of
    // DENSO WAVE INCORPORATED
    //  http://www.denso-wave.com/qrcode/faqpatent-e.html
    //
    //---------------------------------------------------------------------
    
    !function(qrcode) {
    
      //---------------------------------------------------------------------
      // overwrite qrcode.stringToBytes
      //---------------------------------------------------------------------
    
      qrcode.stringToBytes = qrcode.stringToBytesFuncs['UTF-8'];
    
    }(qrcode);
  </script>
  <script type="module" src="./renderer.ts"></script>
</html>
